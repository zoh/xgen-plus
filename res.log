file test/complex_xsd/SCL_Substation.xsd
file test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_Communication.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Communication.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Substation.xsd
file test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Substation.xsd
file test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_Communication.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_Communication.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Substation.xsd
file test/complex_xsd/SCL_Substation.xsd
file test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_Communication.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Substation.xsd
file test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_Communication.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Substation.xsd
file test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_Communication.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Substation.xsd
file test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_Communication.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="OutputDir test/go/output/test/complex_xsd"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: SCL"
/---------------------------------------------------/
package schema

import (
	"fmt"
)

// "ComplexType"
// SCL ...
type SCL struct {
	TBaseElement
	VersionAttr       TSclVersion        `xml:"version,attr" json:"version"`
	RevisionAttr      TSclRevision       `xml:"revision,attr" json:"revision"`
	ReleaseAttr       TSclRelease        `xml:"release,attr" json:"release"`
	Header            THeader            `xml:"Header" json:"Header"`
	Substation        []TSubstation      `xml:"Substation" json:"Substation"`
	Communication     *TCommunication    `xml:"Communication" json:"Communication"`
	IED               []TIED             `xml:"IED" json:"IED"`
	DataTypeTemplates *DataTypeTemplates `xml:"DataTypeTemplates" json:"DataTypeTemplates"`
	Line              []TLine            `xml:"Line" json:"Line"`
	Process           []TProcess         `xml:"Process" json:"Process"`
}

func (t *SCL) Validate() error {
	if err := t.TBaseElement.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.VersionAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tSclVersion"
	if t.VersionAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "version", "SCL")
	}
	if err := t.RevisionAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tSclRevision"
	if t.RevisionAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "revision", "SCL")
	}
	if err := t.ReleaseAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tSclRelease"
	if t.ReleaseAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "release", "SCL")
	}
	// Elements
	if err := CheckValidate(t.Header); err != nil {
		return err
	}
	for _, el := range t.Substation {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	if err := CheckValidate(t.Communication); err != nil {
		return err
	}
	for _, el := range t.IED {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	if err := CheckValidate(t.DataTypeTemplates); err != nil {
		return err
	}
	for _, el := range t.Line {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Process {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "Element"

/---------------------------------------------------/
Done. test/complex_xsd/SCL.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="OutputDir test/go/output/test/complex_xsd"
/---------------------------------------------------/
package schema

import (
	"encoding/xml"
	"errors"
	"regexp"
)

// "SimpleType"
// base:"xs:normalizedString"
// TConnectivityNodeReference ...
type TConnectivityNodeReference string

func (t *TConnectivityNodeReference) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^.+/.+(/.+)*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TConnectivityNodeReference")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TAnyName ...
type TAnyName string

func (t *TAnyName) Validate() error {

	return nil
}

// "SimpleType"
// base:"tAnyName"
// TName ...
type TName string

func (t *TName) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TName")
	}

	return nil
}

// "SimpleType"
// base:"xs:token"
// TID ...
type TID string

func (t *TID) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^\S+$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TID")
	}
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TID")
	}
	if len(*t) > 255 {
		return errors.New("больше макс значения 255 в TID")
	}

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TAcsiName ...
type TAcsiName string

func (t *TAcsiName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Za-z][0-9A-Za-z_]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TAcsiName")
	}

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TRestrName1stU ...
type TRestrName1stU string

func (t *TRestrName1stU) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Z][0-9A-Za-z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TRestrName1stU")
	}

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TRestrName1stL ...
type TRestrName1stL string

func (t *TRestrName1stL) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[a-z][0-9A-Za-z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TRestrName1stL")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TPAddr ...
type TPAddr string

func (t *TPAddr) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TPAddr")
	}

	return nil
}

// "SimpleType"
// base:"tName"
// TSclVersion ...
type TSclVersion string

func (t *TSclVersion) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^2[0-2][0-9]{2}$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TSclVersion")
	}

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TSclRevision ...
type TSclRevision string

func (t *TSclRevision) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Z]$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TSclRevision")
	}

	return nil
}

// "SimpleType"
// base:"xs:unsignedByte"
// TSclRelease ...
type TSclRelease byte

func (t *TSclRelease) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TEmpty ...
type TEmpty string

func (t *TEmpty) Validate() error {

	return nil
}

// "SimpleType"
// base:"tAcsiName"
// TIEDName ...
type TIEDName string

func (t *TIEDName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Za-z][0-9A-Za-z_]{0,2}$`, `^[A-Za-z][0-9A-Za-z_]{4,63}$`, `^[A-MO-Za-z][0-9A-Za-z_]{3}$`, `^N[0-9A-Za-np-z_][0-9A-Za-z_]{2}$`, `^No[0-9A-Za-mo-z_][0-9A-Za-z_]$`, `^Non[0-9A-Za-df-z_]$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TIEDName")
	}
	if len(*t) > 64 {
		return errors.New("больше макс значения 64 в TIEDName")
	}

	return nil
}

// "SimpleType"
// base:"tAcsiName"
// TIEDNameIsNone ...
type TIEDNameIsNone string

func (t *TIEDNameIsNone) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^None$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TIEDNameIsNone")
	}

	return nil
}

// "SimpleType"
// TIEDNameOrNone ...
type TIEDNameOrNone struct { /* UNION */
	Content        string `xml:",chardata" json:",omitempty"`
	tIEDName       *TIEDName
	tIEDNameIsNone *TIEDNameIsNone
}

func (t *TIEDNameOrNone) IsEmpty() bool { return t.Content == "" }
func (t *TIEDNameOrNone) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TIEDNameOrNone) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TIEDNameOrNone) Validate() error {
	{
		p := TIEDName(t.Content)
		t.tIEDName = &p
		if err := t.tIEDName.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tIEDName = nil
		}
	}
	{
		p := TIEDNameIsNone(t.Content)
		t.tIEDNameIsNone = &p
		if err := t.tIEDNameIsNone.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tIEDNameIsNone = nil
		}
	}
	return errors.New("не нашли member from union TIEDNameOrNone")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TOnlyRelativeIEDName ...
type TOnlyRelativeIEDName string

func (t *TOnlyRelativeIEDName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^@$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TOnlyRelativeIEDName")
	}

	return nil
}

// "SimpleType"
// TIEDNameOrRelative ...
type TIEDNameOrRelative struct { /* UNION */
	Content              string `xml:",chardata" json:",omitempty"`
	tIEDName             *TIEDName
	tOnlyRelativeIEDName *TOnlyRelativeIEDName
}

func (t *TIEDNameOrRelative) IsEmpty() bool { return t.Content == "" }
func (t *TIEDNameOrRelative) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TIEDNameOrRelative) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TIEDNameOrRelative) Validate() error {
	{
		p := TIEDName(t.Content)
		t.tIEDName = &p
		if err := t.tIEDName.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tIEDName = nil
		}
	}
	{
		p := TOnlyRelativeIEDName(t.Content)
		t.tOnlyRelativeIEDName = &p
		if err := t.tOnlyRelativeIEDName.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tOnlyRelativeIEDName = nil
		}
	}
	return errors.New("не нашли member from union TIEDNameOrRelative")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TLDName ...
type TLDName string

func (t *TLDName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Za-z][0-9A-Za-z_]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TLDName")
	}
	if len(*t) > 64 {
		return errors.New("больше макс значения 64 в TLDName")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TLDInst ...
type TLDInst string

func (t *TLDInst) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Za-z0-9][0-9A-Za-z_]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TLDInst")
	}
	if len(*t) > 64 {
		return errors.New("больше макс значения 64 в TLDInst")
	}

	return nil
}

// "SimpleType"
// TLDInstOrEmpty ...
type TLDInstOrEmpty struct { /* UNION */
	Content string `xml:",chardata" json:",omitempty"`
	tLDInst *TLDInst
	tEmpty  *TEmpty
}

func (t *TLDInstOrEmpty) IsEmpty() bool { return t.Content == "" }
func (t *TLDInstOrEmpty) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TLDInstOrEmpty) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TLDInstOrEmpty) Validate() error {
	{
		p := TLDInst(t.Content)
		t.tLDInst = &p
		if err := t.tLDInst.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tLDInst = nil
		}
	}
	{
		p := TEmpty(t.Content)
		t.tEmpty = &p
		if err := t.tEmpty.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tEmpty = nil
		}
	}
	return errors.New("не нашли member from union TLDInstOrEmpty")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TPrefix ...
type TPrefix string

func (t *TPrefix) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Za-z][0-9A-Za-z_]*$`, `^$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TPrefix")
	}
	if len(*t) > 11 {
		return errors.New("больше макс значения 11 в TPrefix")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TLNInst ...
type TLNInst string

func (t *TLNInst) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[0-9]{1,12}$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TLNInst")
	}

	return nil
}

// "SimpleType"
// TLNInstOrEmpty ...
type TLNInstOrEmpty struct { /* UNION */
	Content string `xml:",chardata" json:",omitempty"`
	tLNInst *TLNInst
	tEmpty  *TEmpty
}

func (t *TLNInstOrEmpty) IsEmpty() bool { return t.Content == "" }
func (t *TLNInstOrEmpty) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TLNInstOrEmpty) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TLNInstOrEmpty) Validate() error {
	{
		p := TLNInst(t.Content)
		t.tLNInst = &p
		if err := t.tLNInst.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tLNInst = nil
		}
	}
	{
		p := TEmpty(t.Content)
		t.tEmpty = &p
		if err := t.tEmpty.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tEmpty = nil
		}
	}
	return errors.New("не нашли member from union TLNInstOrEmpty")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"tRestrName1stU"
// TDataName ...
type TDataName string

func (t *TDataName) Validate() error {
	if len(*t) > 12 {
		return errors.New("больше макс значения 12 в TDataName")
	}

	return nil
}

// "SimpleType"
// base:"tAcsiName"
// TDataSetName ...
type TDataSetName string

func (t *TDataSetName) Validate() error {
	if len(*t) > 32 {
		return errors.New("больше макс значения 32 в TDataSetName")
	}

	return nil
}

// "SimpleType"
// base:"tAcsiName"
// TCBName ...
type TCBName string

func (t *TCBName) Validate() error {
	if len(*t) > 32 {
		return errors.New("больше макс значения 32 в TCBName")
	}

	return nil
}

// "SimpleType"
// base:"tAcsiName"
// TLogName ...
type TLogName string

func (t *TLogName) Validate() error {
	if len(*t) > 32 {
		return errors.New("больше макс значения 32 в TLogName")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TAccessPointName ...
type TAccessPointName string

func (t *TAccessPointName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Za-z0-9][0-9A-Za-z_]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TAccessPointName")
	}
	if len(*t) > 32 {
		return errors.New("больше макс значения 32 в TAccessPointName")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TAssociationID ...
type TAssociationID string

func (t *TAssociationID) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[0-9A-Za-z]+$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TAssociationID")
	}
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TAssociationID")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TVisibleBasicLatin ...
type TVisibleBasicLatin string

func (t *TVisibleBasicLatin) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[ -~]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TVisibleBasicLatin")
	}

	return nil
}

// "SimpleType"
// base:"tVisibleBasicLatin"
// TMessageID ...
type TMessageID string

func (t *TMessageID) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TMessageID")
	}
	if len(*t) > 129 {
		return errors.New("больше макс значения 129 в TMessageID")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TFullAttributeName ...
type TFullAttributeName string

func (t *TFullAttributeName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[a-zA-Z][a-zA-Z0-9]*(\([0-9]+\))?(\.[a-zA-Z][a-zA-Z0-9]*(\([0-9]+\))?)*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TFullAttributeName")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TFullDOName ...
type TFullDOName string

func (t *TFullDOName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Z][0-9A-Za-z]{0,11}(\.[a-z][0-9A-Za-z]*(\([0-9]+\))?)?$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TFullDOName")
	}

	return nil
}

// "SimpleType"
// base:"tRestrName1stL"
// TSubDataName ...
type TSubDataName string

func (t *TSubDataName) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TSubDataName")
	}
	if len(*t) > 60 {
		return errors.New("больше макс значения 60 в TSubDataName")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TNamespaceName ...
type TNamespaceName string

func (t *TNamespaceName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[ -~]+:20\d\d[A-Z]?$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TNamespaceName")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TLineType ...
type TLineType string

func (t *TLineType) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TLineType")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TProcessType ...
type TProcessType string

func (t *TProcessType) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TProcessType")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TProcessName ...
type TProcessName string

func (t *TProcessName) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^.+(/.+)*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TProcessName")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TEnumStringValue ...
type TEnumStringValue string

func (t *TEnumStringValue) Validate() error {
	if len(*t) > 127 {
		return errors.New("больше макс значения 127 в TEnumStringValue")
	}

	return nil
}

/---------------------------------------------------/
Done. test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="OutputDir test/go/output/test/complex_xsd"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tBaseElement"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tUnNaming"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tNaming"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tIDNaming"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tAnyContentFromOtherNamespace"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tText"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tPrivate"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: History"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tHeader"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tHitem"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tVal"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tValueWithUnit"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tVoltage"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tDurationInSec"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tDurationInMilliSec"
time="2021-11-12T22:35:55+03:00" level=info msg="Render complex type: tBitRateInMbPerSec"
/---------------------------------------------------/
package schema

import (
	"errors"
	"fmt"
)

// "AttributeGroup"
// AgDesc ...
type AgDesc struct {
	DescAttr *string `xml:"desc,attr,omitempty" json:"desc,omitempty"`
}

func (t *AgDesc) Validate() error {

	return nil
}

// "ComplexType"
// TBaseElement ...
type TBaseElement struct {
	NodeID
	AdditionalFields AdditionalFieldsType `xml:",any,attr"`
	CustomElements   []AnyHolder          `xml:",any"`
	Text             *TText               `xml:"Text" json:"Text"`
	Private          []TPrivate           `xml:"Private" json:"Private"`
}

func (t *TBaseElement) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements
	if err := CheckValidate(t.Text); err != nil {
		return err
	}
	for _, el := range t.Private {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TUnNaming ...
type TUnNaming struct {
	TBaseElement
	AgDesc // AttributeGroup
}

func (t *TUnNaming) Validate() error {
	if err := t.TBaseElement.Validate(); err != nil {
		return err
	}
	// AttributeGroup
	if err := t.AgDesc.Validate(); err != nil {
		return err
	}

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TNaming ...
type TNaming struct {
	TBaseElement
	AgDesc         // AttributeGroup
	NameAttr TName `xml:"name,attr" json:"name"`
}

func (t *TNaming) Validate() error {
	if err := t.TBaseElement.Validate(); err != nil {
		return err
	}
	// AttributeGroup
	if err := t.AgDesc.Validate(); err != nil {
		return err
	}

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tName"
	if t.NameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "name", "TNaming")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TIDNaming ...
type TIDNaming struct {
	TBaseElement
	AgDesc     // AttributeGroup
	IdAttr TID `xml:"id,attr" json:"id"`
}

func (t *TIDNaming) Validate() error {
	if err := t.TBaseElement.Validate(); err != nil {
		return err
	}
	// AttributeGroup
	if err := t.AgDesc.Validate(); err != nil {
		return err
	}

	// Attributes
	if err := t.IdAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tID"
	if t.IdAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "id", "TIDNaming")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TAnyContentFromOtherNamespace ...
type TAnyContentFromOtherNamespace struct {
	NodeID
	AdditionalFields AdditionalFieldsType `xml:",any,attr"`
	CustomElements   []AnyHolder          `xml:",any"`
}

func (t *TAnyContentFromOtherNamespace) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TText ...
type TText struct {
	TAnyContentFromOtherNamespace
	SourceAttr *string `xml:"source,attr,omitempty" json:"source,omitempty"`
}

func (t *TText) Validate() error {
	if err := t.TAnyContentFromOtherNamespace.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TPrivateTypeNormalizedString ...
type TPrivateTypeNormalizedString string

func (t *TPrivateTypeNormalizedString) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TPrivateTypeNormalizedString")
	}

	return nil
}

// "ComplexType"
// TPrivate ...
type TPrivate struct {
	TAnyContentFromOtherNamespace
	TypeAttr   TPrivateTypeNormalizedString `xml:"type,attr" json:"type"`
	SourceAttr *string                      `xml:"source,attr,omitempty" json:"source,omitempty"`
}

func (t *TPrivate) Validate() error {
	if err := t.TAnyContentFromOtherNamespace.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type=""
	if t.TypeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPrivate")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// History ...
type History struct {
	NodeID
	Hitem []THitem `xml:"Hitem" json:"Hitem"`
}

func (t *History) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.Hitem {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:Name"
// THeaderNameStructureName ...
type THeaderNameStructureName string

func (t *THeaderNameStructureName) Validate() error {
	// check all enums
	switch *t {
	case THeaderNameStructureName_IEDName:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "THeaderNameStructureName")
	}

	return nil
}

const (
	THeaderNameStructureName_IEDName THeaderNameStructureName = "IEDName"
)

// "ComplexType"
// THeader ...
type THeader struct {
	NodeID
	IdAttr            string                    `xml:"id,attr" json:"id"`
	VersionAttr       *string                   `xml:"version,attr,omitempty" json:"version,omitempty"`
	RevisionAttr      *string                   `xml:"revision,attr,omitempty" json:"revision,omitempty"`
	ToolIDAttr        *string                   `xml:"toolID,attr,omitempty" json:"toolID,omitempty"`
	NameStructureAttr *THeaderNameStructureName `xml:"nameStructure,attr,omitempty" json:"nameStructure,omitempty"`
	Text              *TText                    `xml:"Text" json:"Text"`
	History           *History                  `xml:"History" json:"History"`
}

func (t *THeader) Validate() error {
	// AttributeGroup

	// Attributes
	// check use='required'  type="string"
	if t.IdAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "id", "THeader")
	}
	if err := t.NameStructureAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.Text); err != nil {
		return err
	}
	if err := CheckValidate(t.History); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// THitem ...
type THitem struct {
	TAnyContentFromOtherNamespace
	VersionAttr  string  `xml:"version,attr" json:"version"`
	RevisionAttr string  `xml:"revision,attr" json:"revision"`
	WhenAttr     string  `xml:"when,attr" json:"when"`
	WhoAttr      *string `xml:"who,attr,omitempty" json:"who,omitempty"`
	WhatAttr     *string `xml:"what,attr,omitempty" json:"what,omitempty"`
	WhyAttr      *string `xml:"why,attr,omitempty" json:"why,omitempty"`
}

func (t *THitem) Validate() error {
	if err := t.TAnyContentFromOtherNamespace.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// check use='required'  type="string"
	if t.VersionAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "version", "THitem")
	}
	// check use='required'  type="string"
	if t.RevisionAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "revision", "THitem")
	}
	// check use='required'  type="string"
	if t.WhenAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "when", "THitem")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TVal ...
type TVal struct {
	NodeID
	Content    string  `xml:",chardata" json:",omitempty"`
	SGroupAttr *uint32 `xml:"sGroup,attr,omitempty" json:"sGroup,omitempty"`
}

func (t *TVal) Validate() error {
	// Content type "string" skipped, is go-based// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TValueWithUnit ...
type TValueWithUnit struct {
	NodeID
	Content        float64              `xml:",chardata" json:",omitempty"`
	UnitAttr       string               `xml:"unit,attr" json:"unit"`
	MultiplierAttr *TUnitMultiplierEnum `xml:"multiplier,attr,omitempty" json:"multiplier,omitempty"`
}

func (t *TValueWithUnit) Validate() error {
	// Content type "float64" skipped, is go-based// AttributeGroup

	// Attributes
	// check use='required'  type="string"
	if t.UnitAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "unit", "TValueWithUnit")
	}
	if err := t.MultiplierAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TVoltage ...
type TVoltage struct {
	TValueWithUnit
	UnitAttr       string               `xml:"unit,attr" json:"unit"`
	MultiplierAttr *TUnitMultiplierEnum `xml:"multiplier,attr,omitempty" json:"multiplier,omitempty"`
}

func (t *TVoltage) Validate() error {
	if err := t.TValueWithUnit.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// check use='required'  type="string"
	if t.UnitAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "unit", "TVoltage")
	}
	if err := t.MultiplierAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDurationInSec ...
type TDurationInSec struct {
	TValueWithUnit
	UnitAttr       string               `xml:"unit,attr" json:"unit"`
	MultiplierAttr *TUnitMultiplierEnum `xml:"multiplier,attr,omitempty" json:"multiplier,omitempty"`
}

func (t *TDurationInSec) Validate() error {
	if err := t.TValueWithUnit.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// check use='required'  type="string"
	if t.UnitAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "unit", "TDurationInSec")
	}
	if err := t.MultiplierAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDurationInMilliSec ...
type TDurationInMilliSec struct {
	NodeID
	Content        float64              `xml:",chardata" json:",omitempty"`
	UnitAttr       *string              `xml:"unit,attr,omitempty" json:"unit,omitempty"`
	MultiplierAttr *TUnitMultiplierEnum `xml:"multiplier,attr,omitempty" json:"multiplier,omitempty"`
}

func (t *TDurationInMilliSec) Validate() error {
	// Content type "float64" skipped, is go-based// AttributeGroup

	// Attributes
	if err := t.MultiplierAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TBitRateInMbPerSec ...
type TBitRateInMbPerSec struct {
	NodeID
	Content        float64              `xml:",chardata" json:",omitempty"`
	UnitAttr       *string              `xml:"unit,attr,omitempty" json:"unit,omitempty"`
	MultiplierAttr *TUnitMultiplierEnum `xml:"multiplier,attr,omitempty" json:"multiplier,omitempty"`
}

func (t *TBitRateInMbPerSec) Validate() error {
	// Content type "float64" skipped, is go-based// AttributeGroup

	// Attributes
	if err := t.MultiplierAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

/---------------------------------------------------/
Done. test/complex_xsd/SCL_BaseTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPbase\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP\" set restriction base=\"tP_IPbase\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-SUBNET\" set restriction base=\"tP_IPbase\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IP-GATEWAY\" set restriction base=\"tP_IPbase\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6base\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6\" set restriction base=\"tP_IPv6base\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-SUBNET\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6-GATEWAY\" set restriction base=\"tP_IPv6base\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_DNSName\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tP_IPv6FlowLabel\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:55+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_OSI-NSAP\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_OSI-TSEL\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_OSI-SSEL\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_OSI-PSEL\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_OSI-AP-Title\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_OSI-AP-Invoke\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_OSI-AE-Qualifier\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_OSI-AE-Invoke\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_MAC-Address\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_APPID\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_VLAN-PRIORITY\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_VLAN-ID\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_Port\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_SNTP-Port\" set restriction base=\"tP_Port\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_MMS-Port\" set restriction base=\"tP_Port\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_UDP-Port\" set restriction base=\"tP_Port\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_TCP-Port\" set restriction base=\"tP_Port\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_IPv6ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_C37-118-IP-Port\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_IPv6-IGMPv3Src\" set restriction base=\"tP_IPv6base\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_IP-IGMPv3Src\" set restriction base=\"tP_IPbase\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tP_IP-ClassOfTraffic\" set restriction base=\"tP\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="OutputDir test/go/output/test/complex_xsd"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tControlBlock"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tCommunication"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSubNetwork"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tConnectedAP"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tAddress"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tGSE"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSMV"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tPhysConn"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_PhysConn"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IPbase"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IP"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IP-SUBNET"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IP-GATEWAY"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IPv6base"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IPv6"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IPv6-SUBNET"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IPv6-GATEWAY"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_DNSName"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IPv6FlowLabel"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_OSI-NSAP"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_OSI-TSEL"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_OSI-SSEL"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_OSI-PSEL"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_OSI-AP-Title"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_OSI-AP-Invoke"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_OSI-AE-Qualifier"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_OSI-AE-Invoke"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_MAC-Address"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_APPID"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_VLAN-PRIORITY"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_VLAN-ID"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_Port"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_SNTP-Port"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_MMS-Port"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_UDP-Port"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_TCP-Port"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IPv6ClassOfTraffic"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_C37-118-IP-Port"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IPv6-IGMPv3Src"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IP-IGMPv3Src"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tP_IP-ClassOfTraffic"
/---------------------------------------------------/
package schema

import (
	"errors"
	"fmt"
)

// "ComplexType"
// TControlBlock ...
type TControlBlock struct {
	TUnNaming
	LdInstAttr TLDInst   `xml:"ldInst,attr" json:"ldInst"`
	CbNameAttr TCBName   `xml:"cbName,attr" json:"cbName"`
	Address    *TAddress `xml:"Address" json:"Address"`
}

func (t *TControlBlock) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.LdInstAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tLDInst"
	if t.LdInstAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "ldInst", "TControlBlock")
	}
	if err := t.CbNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tCBName"
	if t.CbNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "cbName", "TControlBlock")
	}
	// Elements
	if err := CheckValidate(t.Address); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TCommunication ...
type TCommunication struct {
	TUnNaming
	SubNetwork []TSubNetwork `xml:"SubNetwork" json:"SubNetwork"`
}

func (t *TCommunication) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.SubNetwork {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TSubNetworkTypeNormalizedString ...
type TSubNetworkTypeNormalizedString string

func (t *TSubNetworkTypeNormalizedString) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TSubNetworkTypeNormalizedString")
	}

	return nil
}

// "ComplexType"
// TSubNetwork ...
type TSubNetwork struct {
	TNaming
	TypeAttr    *TSubNetworkTypeNormalizedString `xml:"type,attr,omitempty" json:"type,omitempty"`
	BitRate     *TBitRateInMbPerSec              `xml:"BitRate" json:"BitRate"`
	ConnectedAP []TConnectedAP                   `xml:"ConnectedAP" json:"ConnectedAP"`
}

func (t *TSubNetwork) Validate() error {
	if err := t.TNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.BitRate); err != nil {
		return err
	}
	for _, el := range t.ConnectedAP {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TConnectedAP ...
type TConnectedAP struct {
	TUnNaming
	IedNameAttr TIEDName         `xml:"iedName,attr" json:"iedName"`
	ApNameAttr  TAccessPointName `xml:"apName,attr" json:"apName"`
	RedProtAttr *string          `xml:"redProt,attr,omitempty" json:"redProt,omitempty"`
	Address     *TAddress        `xml:"Address" json:"Address"`
	GSE         []TGSE           `xml:"GSE" json:"GSE"`
	SMV         []TSMV           `xml:"SMV" json:"SMV"`
	PhysConn    []TPhysConn      `xml:"PhysConn" json:"PhysConn"`
}

func (t *TConnectedAP) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.IedNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tIEDName"
	if t.IedNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "iedName", "TConnectedAP")
	}
	if err := t.ApNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tAccessPointName"
	if t.ApNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "apName", "TConnectedAP")
	}
	// Elements
	if err := CheckValidate(t.Address); err != nil {
		return err
	}
	for _, el := range t.GSE {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.SMV {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.PhysConn {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TAddress ...
type TAddress struct {
	NodeID
	P []TP `xml:"P" json:"P"`
}

func (t *TAddress) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.P {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TGSE ...
type TGSE struct {
	TControlBlock
	MinTime *TDurationInMilliSec `xml:"MinTime" json:"MinTime"`
	MaxTime *TDurationInMilliSec `xml:"MaxTime" json:"MaxTime"`
}

func (t *TGSE) Validate() error {
	if err := t.TControlBlock.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	if err := CheckValidate(t.MinTime); err != nil {
		return err
	}
	if err := CheckValidate(t.MaxTime); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSMV ...
type TSMV struct {
	TControlBlock
}

func (t *TSMV) Validate() error {
	if err := t.TControlBlock.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPhysConn ...
type TPhysConn struct {
	TUnNaming
	TypeAttr TPhysConnTypeEnum `xml:"type,attr" json:"type"`
	P        []TPPhysConn      `xml:"P" json:"P"`
}

func (t *TPhysConn) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPhysConnTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPhysConn")
	}
	// Elements
	for _, el := range t.P {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPPhysConn ...
type TPPhysConn struct {
	NodeID
	*TPAddr  `xml:",chardata" json:",omitempty"`
	TypeAttr TPTypePhysConnEnum `xml:"type,attr" json:"type"`
}

func (t *TPPhysConn) Validate() error {
	if err := t.TPAddr.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypePhysConnEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPPhysConn")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TP ...
type TP struct {
	NodeID
	*TPAddr  `xml:",chardata" json:",omitempty"`
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TP) Validate() error {
	if err := t.TPAddr.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TP")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPbase ...
type TPIPbase struct {
	TP
}

func (t *TPIPbase) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIP ...
type TPIP struct {
	TPIPbase
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIP) Validate() error {
	if err := t.TPIPbase.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIP")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPSUBNET ...
type TPIPSUBNET struct {
	TPIPbase
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPSUBNET) Validate() error {
	if err := t.TPIPbase.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPSUBNET")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPGATEWAY ...
type TPIPGATEWAY struct {
	TPIPbase
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPGATEWAY) Validate() error {
	if err := t.TPIPbase.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPGATEWAY")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPv6base ...
type TPIPv6base struct {
	TP
}

func (t *TPIPv6base) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPv6 ...
type TPIPv6 struct {
	TPIPv6base
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPv6) Validate() error {
	if err := t.TPIPv6base.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPv6")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPv6SUBNET ...
type TPIPv6SUBNET struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPv6SUBNET) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPv6SUBNET")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPv6GATEWAY ...
type TPIPv6GATEWAY struct {
	TPIPv6base
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPv6GATEWAY) Validate() error {
	if err := t.TPIPv6base.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPv6GATEWAY")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPDNSName ...
type TPDNSName struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPDNSName) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPDNSName")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPv6FlowLabel ...
type TPIPv6FlowLabel struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPv6FlowLabel) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPv6FlowLabel")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPOSINSAP ...
type TPOSINSAP struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPOSINSAP) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPOSINSAP")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPOSITSEL ...
type TPOSITSEL struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPOSITSEL) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPOSITSEL")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPOSISSEL ...
type TPOSISSEL struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPOSISSEL) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPOSISSEL")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPOSIPSEL ...
type TPOSIPSEL struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPOSIPSEL) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPOSIPSEL")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPOSIAPTitle ...
type TPOSIAPTitle struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPOSIAPTitle) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPOSIAPTitle")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPOSIAPInvoke ...
type TPOSIAPInvoke struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPOSIAPInvoke) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPOSIAPInvoke")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPOSIAEQualifier ...
type TPOSIAEQualifier struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPOSIAEQualifier) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPOSIAEQualifier")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPOSIAEInvoke ...
type TPOSIAEInvoke struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPOSIAEInvoke) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPOSIAEInvoke")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPMACAddress ...
type TPMACAddress struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPMACAddress) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPMACAddress")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPAPPID ...
type TPAPPID struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPAPPID) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPAPPID")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPVLANPRIORITY ...
type TPVLANPRIORITY struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPVLANPRIORITY) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPVLANPRIORITY")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPVLANID ...
type TPVLANID struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPVLANID) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPVLANID")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPPort ...
type TPPort struct {
	TP
}

func (t *TPPort) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPSNTPPort ...
type TPSNTPPort struct {
	TPPort
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPSNTPPort) Validate() error {
	if err := t.TPPort.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPSNTPPort")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPMMSPort ...
type TPMMSPort struct {
	TPPort
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPMMSPort) Validate() error {
	if err := t.TPPort.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPMMSPort")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPUDPPort ...
type TPUDPPort struct {
	TPPort
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPUDPPort) Validate() error {
	if err := t.TPPort.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPUDPPort")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPTCPPort ...
type TPTCPPort struct {
	TPPort
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPTCPPort) Validate() error {
	if err := t.TPPort.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPTCPPort")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPv6ClassOfTraffic ...
type TPIPv6ClassOfTraffic struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPv6ClassOfTraffic) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPv6ClassOfTraffic")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPC37118IPPort ...
type TPC37118IPPort struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPC37118IPPort) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPC37118IPPort")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPv6IGMPv3Src ...
type TPIPv6IGMPv3Src struct {
	TPIPv6base
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPv6IGMPv3Src) Validate() error {
	if err := t.TPIPv6base.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPv6IGMPv3Src")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPIGMPv3Src ...
type TPIPIGMPv3Src struct {
	TPIPbase
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPIGMPv3Src) Validate() error {
	if err := t.TPIPbase.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPIGMPv3Src")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPIPClassOfTraffic ...
type TPIPClassOfTraffic struct {
	TP
	TypeAttr TPTypeEnum `xml:"type,attr" json:"type"`
}

func (t *TPIPClassOfTraffic) Validate() error {
	if err := t.TP.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPTypeEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPIPClassOfTraffic")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "Element"
// Communication ...
type Communication = TCommunication

/---------------------------------------------------/
Done. test/complex_xsd/SCL_Communication.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="OutputDir test/go/output/test/complex_xsd"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tAbstractDataAttribute"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLNodeType"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tDO"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tDOType"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSDO"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tDA"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tDAType"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tBDA"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tEnumType"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tProtNs"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tEnumVal"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tDataTypeTemplates"
/---------------------------------------------------/
package schema

import (
	"errors"
	"fmt"
)

// "AttributeGroup"
// AgDATrgOp ...
type AgDATrgOp struct {
	DchgAttr *bool `xml:"dchg,attr,omitempty" json:"dchg,omitempty"`
	QchgAttr *bool `xml:"qchg,attr,omitempty" json:"qchg,omitempty"`
	DupdAttr *bool `xml:"dupd,attr,omitempty" json:"dupd,omitempty"`
}

func (t *AgDATrgOp) Validate() error {

	return nil
}

// "ComplexType"
// TAbstractDataAttribute ...
type TAbstractDataAttribute struct {
	TUnNaming
	NameAttr      TAttributeNameEnum `xml:"name,attr" json:"name"`
	SAddrAttr     *string            `xml:"sAddr,attr,omitempty" json:"sAddr,omitempty"`
	BTypeAttr     TBasicTypeEnum     `xml:"bType,attr" json:"bType"`
	ValKindAttr   *TValKindEnum      `xml:"valKind,attr,omitempty" json:"valKind,omitempty"`
	TypeAttr      *TAnyName          `xml:"type,attr,omitempty" json:"type,omitempty"`
	CountAttr     *TDACount          `xml:"count,attr,omitempty" json:"count,omitempty"`
	ValImportAttr *bool              `xml:"valImport,attr,omitempty" json:"valImport,omitempty"`
	Val           []TVal             `xml:"Val" json:"Val"`
}

func (t *TAbstractDataAttribute) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tAttributeNameEnum"
	if t.NameAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "name", "TAbstractDataAttribute")
	}
	if err := t.BTypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tBasicTypeEnum"
	if t.BTypeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "bType", "TAbstractDataAttribute")
	}
	if err := t.ValKindAttr.Validate(); err != nil {
		return err
	}
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	if err := t.CountAttr.Validate(); err != nil {
		return err
	}
	// Elements
	for _, el := range t.Val {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TLNodeType ...
type TLNodeType struct {
	TIDNaming
	IedTypeAttr *TAnyName    `xml:"iedType,attr,omitempty" json:"iedType,omitempty"`
	LnClassAttr TLNClassEnum `xml:"lnClass,attr" json:"lnClass"`
	DO          []TDO        `xml:"DO" json:"DO"`
}

func (t *TLNodeType) Validate() error {
	if err := t.TIDNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.IedTypeAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tLNClassEnum"
	if t.LnClassAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "lnClass", "TLNodeType")
	}
	// Elements
	for _, el := range t.DO {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDO ...
type TDO struct {
	TUnNaming
	NameAttr          TDataName `xml:"name,attr" json:"name"`
	TypeAttr          TName     `xml:"type,attr" json:"type"`
	AccessControlAttr *string   `xml:"accessControl,attr,omitempty" json:"accessControl,omitempty"`
	TransientAttr     *bool     `xml:"transient,attr,omitempty" json:"transient,omitempty"`
}

func (t *TDO) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tDataName"
	if t.NameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "name", "TDO")
	}
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tName"
	if t.TypeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "type", "TDO")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDOType ...
type TDOType struct {
	TIDNaming
	IedTypeAttr *TAnyName `xml:"iedType,attr,omitempty" json:"iedType,omitempty"`
	CdcAttr     TCDCEnum  `xml:"cdc,attr" json:"cdc"`
	SDO         []TSDO    `xml:"SDO" json:"SDO"`
	DA          []TDA     `xml:"DA" json:"DA"`
}

func (t *TDOType) Validate() error {
	if err := t.TIDNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.IedTypeAttr.Validate(); err != nil {
		return err
	}
	if err := t.CdcAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tCDCEnum"
	if t.CdcAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "cdc", "TDOType")
	}
	// Elements
	for _, el := range t.SDO {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.DA {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSDO ...
type TSDO struct {
	TUnNaming
	NameAttr  TSubDataName `xml:"name,attr" json:"name"`
	TypeAttr  TName        `xml:"type,attr" json:"type"`
	CountAttr *TSDOCount   `xml:"count,attr,omitempty" json:"count,omitempty"`
}

func (t *TSDO) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tSubDataName"
	if t.NameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "name", "TSDO")
	}
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tName"
	if t.TypeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "type", "TSDO")
	}
	if err := t.CountAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDA ...
type TDA struct {
	TAbstractDataAttribute
	AgDATrgOp           // AttributeGroup
	FcAttr    TFCEnum   `xml:"fc,attr" json:"fc"`
	ProtNs    []TProtNs `xml:"ProtNs" json:"ProtNs"`
}

func (t *TDA) Validate() error {
	if err := t.TAbstractDataAttribute.Validate(); err != nil {
		return err
	}
	// AttributeGroup
	if err := t.AgDATrgOp.Validate(); err != nil {
		return err
	}

	// Attributes
	if err := t.FcAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tFCEnum"
	if t.FcAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "fc", "TDA")
	}
	// Elements
	for _, el := range t.ProtNs {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDAType ...
type TDAType struct {
	TIDNaming
	IedTypeAttr *TAnyName `xml:"iedType,attr,omitempty" json:"iedType,omitempty"`
	BDA         []TBDA    `xml:"BDA" json:"BDA"`
	ProtNs      []TProtNs `xml:"ProtNs" json:"ProtNs"`
}

func (t *TDAType) Validate() error {
	if err := t.TIDNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.IedTypeAttr.Validate(); err != nil {
		return err
	}
	// Elements
	for _, el := range t.BDA {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.ProtNs {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TBDA ...
type TBDA struct {
	TAbstractDataAttribute
}

func (t *TBDA) Validate() error {
	if err := t.TAbstractDataAttribute.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TEnumType ...
type TEnumType struct {
	TIDNaming
	EnumVal []TEnumVal `xml:"EnumVal" json:"EnumVal"`
}

func (t *TEnumType) Validate() error {
	if err := t.TIDNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.EnumVal {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TProtNsTypeNormalizedString ...
type TProtNsTypeNormalizedString string

func (t *TProtNsTypeNormalizedString) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TProtNsTypeNormalizedString")
	}

	return nil
}

// "ComplexType"
// TProtNs ...
type TProtNs struct {
	NodeID
	*TNamespaceName `xml:",chardata" json:",omitempty"`
	TypeAttr        *TProtNsTypeNormalizedString `xml:"type,attr,omitempty" json:"type,omitempty"`
}

func (t *TProtNs) Validate() error {
	if err := t.TNamespaceName.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TEnumVal ...
type TEnumVal struct {
	NodeID
	*TEnumStringValue `xml:",chardata" json:",omitempty"`
	AgDesc                // AttributeGroup
	OrdAttr           int `xml:"ord,attr" json:"ord"`
}

func (t *TEnumVal) Validate() error {
	if err := t.TEnumStringValue.Validate(); err != nil {
		return err
	}
	// AttributeGroup
	if err := t.AgDesc.Validate(); err != nil {
		return err
	}

	// Attributes
	// check use='required'  type="int"
	if t.OrdAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "ord", "TEnumVal")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDataTypeTemplates ...
type TDataTypeTemplates struct {
	NodeID
	LNodeType []TLNodeType `xml:"LNodeType" json:"LNodeType"`
	DOType    []TDOType    `xml:"DOType" json:"DOType"`
	DAType    []TDAType    `xml:"DAType" json:"DAType"`
	EnumType  []TEnumType  `xml:"EnumType" json:"EnumType"`
}

func (t *TDataTypeTemplates) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.LNodeType {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.DOType {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.DAType {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.EnumType {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "Element"
// DataTypeTemplates ...
type DataTypeTemplates = TDataTypeTemplates

/---------------------------------------------------/
Done. test/complex_xsd/SCL_DataTypeTemplates.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="OutputDir test/go/output/test/complex_xsd"
/---------------------------------------------------/
package schema

import (
	"encoding/xml"
	"errors"
	"fmt"
	"regexp"
)

// "SimpleType"
// base:"xs:Name"
// TPredefinedPTypeEnum ...
type TPredefinedPTypeEnum string

func (t *TPredefinedPTypeEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedPTypeEnum_IP:
	case TPredefinedPTypeEnum_IPSUBNET:
	case TPredefinedPTypeEnum_IPGATEWAY:
	case TPredefinedPTypeEnum_OSINSAP:
	case TPredefinedPTypeEnum_OSITSEL:
	case TPredefinedPTypeEnum_OSISSEL:
	case TPredefinedPTypeEnum_OSIPSEL:
	case TPredefinedPTypeEnum_OSIAPTitle:
	case TPredefinedPTypeEnum_OSIAPInvoke:
	case TPredefinedPTypeEnum_OSIAEQualifier:
	case TPredefinedPTypeEnum_OSIAEInvoke:
	case TPredefinedPTypeEnum_MACAddress:
	case TPredefinedPTypeEnum_APPID:
	case TPredefinedPTypeEnum_VLANPRIORITY:
	case TPredefinedPTypeEnum_VLANID:
	case TPredefinedPTypeEnum_SNTPPort:
	case TPredefinedPTypeEnum_MMSPort:
	case TPredefinedPTypeEnum_DNSName:
	case TPredefinedPTypeEnum_IPv6FlowLabel:
	case TPredefinedPTypeEnum_IPv6ClassOfTraffic:
	case TPredefinedPTypeEnum_C37118IPPort:
	case TPredefinedPTypeEnum_IPUDPPORT:
	case TPredefinedPTypeEnum_IPTCPPORT:
	case TPredefinedPTypeEnum_IPv6:
	case TPredefinedPTypeEnum_IPv6SUBNET:
	case TPredefinedPTypeEnum_IPv6GATEWAY:
	case TPredefinedPTypeEnum_IPv6IGMPv3Src:
	case TPredefinedPTypeEnum_IPIGMPv3Src:
	case TPredefinedPTypeEnum_IPClassOfTraffic:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedPTypeEnum")
	}

	return nil
}

const (
	TPredefinedPTypeEnum_IP                 TPredefinedPTypeEnum = "IP"
	TPredefinedPTypeEnum_IPSUBNET           TPredefinedPTypeEnum = "IP-SUBNET"
	TPredefinedPTypeEnum_IPGATEWAY          TPredefinedPTypeEnum = "IP-GATEWAY"
	TPredefinedPTypeEnum_OSINSAP            TPredefinedPTypeEnum = "OSI-NSAP"
	TPredefinedPTypeEnum_OSITSEL            TPredefinedPTypeEnum = "OSI-TSEL"
	TPredefinedPTypeEnum_OSISSEL            TPredefinedPTypeEnum = "OSI-SSEL"
	TPredefinedPTypeEnum_OSIPSEL            TPredefinedPTypeEnum = "OSI-PSEL"
	TPredefinedPTypeEnum_OSIAPTitle         TPredefinedPTypeEnum = "OSI-AP-Title"
	TPredefinedPTypeEnum_OSIAPInvoke        TPredefinedPTypeEnum = "OSI-AP-Invoke"
	TPredefinedPTypeEnum_OSIAEQualifier     TPredefinedPTypeEnum = "OSI-AE-Qualifier"
	TPredefinedPTypeEnum_OSIAEInvoke        TPredefinedPTypeEnum = "OSI-AE-Invoke"
	TPredefinedPTypeEnum_MACAddress         TPredefinedPTypeEnum = "MAC-Address"
	TPredefinedPTypeEnum_APPID              TPredefinedPTypeEnum = "APPID"
	TPredefinedPTypeEnum_VLANPRIORITY       TPredefinedPTypeEnum = "VLAN-PRIORITY"
	TPredefinedPTypeEnum_VLANID             TPredefinedPTypeEnum = "VLAN-ID"
	TPredefinedPTypeEnum_SNTPPort           TPredefinedPTypeEnum = "SNTP-Port"
	TPredefinedPTypeEnum_MMSPort            TPredefinedPTypeEnum = "MMS-Port"
	TPredefinedPTypeEnum_DNSName            TPredefinedPTypeEnum = "DNSName"
	TPredefinedPTypeEnum_IPv6FlowLabel      TPredefinedPTypeEnum = "IPv6FlowLabel"
	TPredefinedPTypeEnum_IPv6ClassOfTraffic TPredefinedPTypeEnum = "IPv6ClassOfTraffic"
	TPredefinedPTypeEnum_C37118IPPort       TPredefinedPTypeEnum = "C37-118-IP-Port"
	TPredefinedPTypeEnum_IPUDPPORT          TPredefinedPTypeEnum = "IP-UDP-PORT"
	TPredefinedPTypeEnum_IPTCPPORT          TPredefinedPTypeEnum = "IP-TCP-PORT"
	TPredefinedPTypeEnum_IPv6               TPredefinedPTypeEnum = "IPv6"
	TPredefinedPTypeEnum_IPv6SUBNET         TPredefinedPTypeEnum = "IPv6-SUBNET"
	TPredefinedPTypeEnum_IPv6GATEWAY        TPredefinedPTypeEnum = "IPv6-GATEWAY"
	TPredefinedPTypeEnum_IPv6IGMPv3Src      TPredefinedPTypeEnum = "IPv6-IGMPv3Src"
	TPredefinedPTypeEnum_IPIGMPv3Src        TPredefinedPTypeEnum = "IP-IGMPv3Src"
	TPredefinedPTypeEnum_IPClassOfTraffic   TPredefinedPTypeEnum = "IP-ClassOfTraffic"
)

// "SimpleType"
// base:"xs:normalizedString"
// TExtensionPTypeEnum ...
type TExtensionPTypeEnum string

func (t *TExtensionPTypeEnum) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Z][0-9A-Za-z\-]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TExtensionPTypeEnum")
	}

	return nil
}

// "SimpleType"
// TPTypeEnum ...
type TPTypeEnum struct { /* UNION */
	Content              string `xml:",chardata" json:",omitempty"`
	tPredefinedPTypeEnum *TPredefinedPTypeEnum
	tExtensionPTypeEnum  *TExtensionPTypeEnum
}

func (t *TPTypeEnum) IsEmpty() bool { return t.Content == "" }
func (t *TPTypeEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TPTypeEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TPTypeEnum) Validate() error {
	{
		p := TPredefinedPTypeEnum(t.Content)
		t.tPredefinedPTypeEnum = &p
		if err := t.tPredefinedPTypeEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tPredefinedPTypeEnum = nil
		}
	}
	{
		p := TExtensionPTypeEnum(t.Content)
		t.tExtensionPTypeEnum = &p
		if err := t.tExtensionPTypeEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tExtensionPTypeEnum = nil
		}
	}
	return errors.New("не нашли member from union TPTypeEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TPredefinedPTypePhysConnEnum ...
type TPredefinedPTypePhysConnEnum string

func (t *TPredefinedPTypePhysConnEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedPTypePhysConnEnum_Type:
	case TPredefinedPTypePhysConnEnum_Plug:
	case TPredefinedPTypePhysConnEnum_Cable:
	case TPredefinedPTypePhysConnEnum_Port:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedPTypePhysConnEnum")
	}

	return nil
}

const (
	TPredefinedPTypePhysConnEnum_Type  TPredefinedPTypePhysConnEnum = "Type"
	TPredefinedPTypePhysConnEnum_Plug  TPredefinedPTypePhysConnEnum = "Plug"
	TPredefinedPTypePhysConnEnum_Cable TPredefinedPTypePhysConnEnum = "Cable"
	TPredefinedPTypePhysConnEnum_Port  TPredefinedPTypePhysConnEnum = "Port"
)

// "SimpleType"
// TPTypePhysConnEnum ...
type TPTypePhysConnEnum struct { /* UNION */
	Content                      string `xml:",chardata" json:",omitempty"`
	tPredefinedPTypePhysConnEnum *TPredefinedPTypePhysConnEnum
	tExtensionPTypeEnum          *TExtensionPTypeEnum
}

func (t *TPTypePhysConnEnum) IsEmpty() bool { return t.Content == "" }
func (t *TPTypePhysConnEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TPTypePhysConnEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TPTypePhysConnEnum) Validate() error {
	{
		p := TPredefinedPTypePhysConnEnum(t.Content)
		t.tPredefinedPTypePhysConnEnum = &p
		if err := t.tPredefinedPTypePhysConnEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tPredefinedPTypePhysConnEnum = nil
		}
	}
	{
		p := TExtensionPTypeEnum(t.Content)
		t.tExtensionPTypeEnum = &p
		if err := t.tExtensionPTypeEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tExtensionPTypeEnum = nil
		}
	}
	return errors.New("не нашли member from union TPTypePhysConnEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TPredefinedAttributeNameEnum ...
type TPredefinedAttributeNameEnum string

func (t *TPredefinedAttributeNameEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedAttributeNameEnum_T:
	case TPredefinedAttributeNameEnum_Test:
	case TPredefinedAttributeNameEnum_Check:
	case TPredefinedAttributeNameEnum_SIUnit:
	case TPredefinedAttributeNameEnum_Oper:
	case TPredefinedAttributeNameEnum_SBO:
	case TPredefinedAttributeNameEnum_SBOw:
	case TPredefinedAttributeNameEnum_Cancel:
	case TPredefinedAttributeNameEnum_Addr:
	case TPredefinedAttributeNameEnum_PRIORITY:
	case TPredefinedAttributeNameEnum_VID:
	case TPredefinedAttributeNameEnum_APPID:
	case TPredefinedAttributeNameEnum_TransportInUse:
	case TPredefinedAttributeNameEnum_IPClassOfTraffic:
	case TPredefinedAttributeNameEnum_IPv6FlowLabel:
	case TPredefinedAttributeNameEnum_IPAddressLength:
	case TPredefinedAttributeNameEnum_IPAddress:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedAttributeNameEnum")
	}

	return nil
}

const (
	TPredefinedAttributeNameEnum_T                TPredefinedAttributeNameEnum = "T"
	TPredefinedAttributeNameEnum_Test             TPredefinedAttributeNameEnum = "Test"
	TPredefinedAttributeNameEnum_Check            TPredefinedAttributeNameEnum = "Check"
	TPredefinedAttributeNameEnum_SIUnit           TPredefinedAttributeNameEnum = "SIUnit"
	TPredefinedAttributeNameEnum_Oper             TPredefinedAttributeNameEnum = "Oper"
	TPredefinedAttributeNameEnum_SBO              TPredefinedAttributeNameEnum = "SBO"
	TPredefinedAttributeNameEnum_SBOw             TPredefinedAttributeNameEnum = "SBOw"
	TPredefinedAttributeNameEnum_Cancel           TPredefinedAttributeNameEnum = "Cancel"
	TPredefinedAttributeNameEnum_Addr             TPredefinedAttributeNameEnum = "Addr"
	TPredefinedAttributeNameEnum_PRIORITY         TPredefinedAttributeNameEnum = "PRIORITY"
	TPredefinedAttributeNameEnum_VID              TPredefinedAttributeNameEnum = "VID"
	TPredefinedAttributeNameEnum_APPID            TPredefinedAttributeNameEnum = "APPID"
	TPredefinedAttributeNameEnum_TransportInUse   TPredefinedAttributeNameEnum = "TransportInUse"
	TPredefinedAttributeNameEnum_IPClassOfTraffic TPredefinedAttributeNameEnum = "IPClassOfTraffic"
	TPredefinedAttributeNameEnum_IPv6FlowLabel    TPredefinedAttributeNameEnum = "IPv6FlowLabel"
	TPredefinedAttributeNameEnum_IPAddressLength  TPredefinedAttributeNameEnum = "IPAddressLength"
	TPredefinedAttributeNameEnum_IPAddress        TPredefinedAttributeNameEnum = "IPAddress"
)

// "SimpleType"
// base:"tRestrName1stL"
// TExtensionAttributeNameEnum ...
type TExtensionAttributeNameEnum string

func (t *TExtensionAttributeNameEnum) Validate() error {
	if len(*t) > 60 {
		return errors.New("больше макс значения 60 в TExtensionAttributeNameEnum")
	}

	return nil
}

// "SimpleType"
// TAttributeNameEnum ...
type TAttributeNameEnum struct { /* UNION */
	Content                      string `xml:",chardata" json:",omitempty"`
	tPredefinedAttributeNameEnum *TPredefinedAttributeNameEnum
	tExtensionAttributeNameEnum  *TExtensionAttributeNameEnum
}

func (t *TAttributeNameEnum) IsEmpty() bool { return t.Content == "" }
func (t *TAttributeNameEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TAttributeNameEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TAttributeNameEnum) Validate() error {
	{
		p := TPredefinedAttributeNameEnum(t.Content)
		t.tPredefinedAttributeNameEnum = &p
		if err := t.tPredefinedAttributeNameEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tPredefinedAttributeNameEnum = nil
		}
	}
	{
		p := TExtensionAttributeNameEnum(t.Content)
		t.tExtensionAttributeNameEnum = &p
		if err := t.tExtensionAttributeNameEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tExtensionAttributeNameEnum = nil
		}
	}
	return errors.New("не нашли member from union TAttributeNameEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TPredefinedCommonConductingEquipmentEnum ...
type TPredefinedCommonConductingEquipmentEnum string

func (t *TPredefinedCommonConductingEquipmentEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedCommonConductingEquipmentEnum_CBR:
	case TPredefinedCommonConductingEquipmentEnum_DIS:
	case TPredefinedCommonConductingEquipmentEnum_VTR:
	case TPredefinedCommonConductingEquipmentEnum_CTR:
	case TPredefinedCommonConductingEquipmentEnum_GEN:
	case TPredefinedCommonConductingEquipmentEnum_CAP:
	case TPredefinedCommonConductingEquipmentEnum_REA:
	case TPredefinedCommonConductingEquipmentEnum_CON:
	case TPredefinedCommonConductingEquipmentEnum_MOT:
	case TPredefinedCommonConductingEquipmentEnum_EFN:
	case TPredefinedCommonConductingEquipmentEnum_PSH:
	case TPredefinedCommonConductingEquipmentEnum_BAT:
	case TPredefinedCommonConductingEquipmentEnum_BSH:
	case TPredefinedCommonConductingEquipmentEnum_CAB:
	case TPredefinedCommonConductingEquipmentEnum_GIL:
	case TPredefinedCommonConductingEquipmentEnum_LIN:
	case TPredefinedCommonConductingEquipmentEnum_RES:
	case TPredefinedCommonConductingEquipmentEnum_RRC:
	case TPredefinedCommonConductingEquipmentEnum_SAR:
	case TPredefinedCommonConductingEquipmentEnum_TCF:
	case TPredefinedCommonConductingEquipmentEnum_TCR:
	case TPredefinedCommonConductingEquipmentEnum_IFL:
	case TPredefinedCommonConductingEquipmentEnum_FAN:
	case TPredefinedCommonConductingEquipmentEnum_SCR:
	case TPredefinedCommonConductingEquipmentEnum_SMC:
	case TPredefinedCommonConductingEquipmentEnum_PMP:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedCommonConductingEquipmentEnum")
	}

	return nil
}

const (
	TPredefinedCommonConductingEquipmentEnum_CBR TPredefinedCommonConductingEquipmentEnum = "CBR"
	TPredefinedCommonConductingEquipmentEnum_DIS TPredefinedCommonConductingEquipmentEnum = "DIS"
	TPredefinedCommonConductingEquipmentEnum_VTR TPredefinedCommonConductingEquipmentEnum = "VTR"
	TPredefinedCommonConductingEquipmentEnum_CTR TPredefinedCommonConductingEquipmentEnum = "CTR"
	TPredefinedCommonConductingEquipmentEnum_GEN TPredefinedCommonConductingEquipmentEnum = "GEN"
	TPredefinedCommonConductingEquipmentEnum_CAP TPredefinedCommonConductingEquipmentEnum = "CAP"
	TPredefinedCommonConductingEquipmentEnum_REA TPredefinedCommonConductingEquipmentEnum = "REA"
	TPredefinedCommonConductingEquipmentEnum_CON TPredefinedCommonConductingEquipmentEnum = "CON"
	TPredefinedCommonConductingEquipmentEnum_MOT TPredefinedCommonConductingEquipmentEnum = "MOT"
	TPredefinedCommonConductingEquipmentEnum_EFN TPredefinedCommonConductingEquipmentEnum = "EFN"
	TPredefinedCommonConductingEquipmentEnum_PSH TPredefinedCommonConductingEquipmentEnum = "PSH"
	TPredefinedCommonConductingEquipmentEnum_BAT TPredefinedCommonConductingEquipmentEnum = "BAT"
	TPredefinedCommonConductingEquipmentEnum_BSH TPredefinedCommonConductingEquipmentEnum = "BSH"
	TPredefinedCommonConductingEquipmentEnum_CAB TPredefinedCommonConductingEquipmentEnum = "CAB"
	TPredefinedCommonConductingEquipmentEnum_GIL TPredefinedCommonConductingEquipmentEnum = "GIL"
	TPredefinedCommonConductingEquipmentEnum_LIN TPredefinedCommonConductingEquipmentEnum = "LIN"
	TPredefinedCommonConductingEquipmentEnum_RES TPredefinedCommonConductingEquipmentEnum = "RES"
	TPredefinedCommonConductingEquipmentEnum_RRC TPredefinedCommonConductingEquipmentEnum = "RRC"
	TPredefinedCommonConductingEquipmentEnum_SAR TPredefinedCommonConductingEquipmentEnum = "SAR"
	TPredefinedCommonConductingEquipmentEnum_TCF TPredefinedCommonConductingEquipmentEnum = "TCF"
	TPredefinedCommonConductingEquipmentEnum_TCR TPredefinedCommonConductingEquipmentEnum = "TCR"
	TPredefinedCommonConductingEquipmentEnum_IFL TPredefinedCommonConductingEquipmentEnum = "IFL"
	TPredefinedCommonConductingEquipmentEnum_FAN TPredefinedCommonConductingEquipmentEnum = "FAN"
	TPredefinedCommonConductingEquipmentEnum_SCR TPredefinedCommonConductingEquipmentEnum = "SCR"
	TPredefinedCommonConductingEquipmentEnum_SMC TPredefinedCommonConductingEquipmentEnum = "SMC"
	TPredefinedCommonConductingEquipmentEnum_PMP TPredefinedCommonConductingEquipmentEnum = "PMP"
)

// "SimpleType"
// base:"xs:Name"
// TExtensionEquipmentEnum ...
type TExtensionEquipmentEnum string

func (t *TExtensionEquipmentEnum) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^E[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TExtensionEquipmentEnum")
	}
	if len(*t) < 3 {
		return errors.New("меньше минимального 3 значение в TExtensionEquipmentEnum")
	}

	return nil
}

// "SimpleType"
// TCommonConductingEquipmentEnum ...
type TCommonConductingEquipmentEnum struct { /* UNION */
	Content                                  string `xml:",chardata" json:",omitempty"`
	tExtensionEquipmentEnum                  *TExtensionEquipmentEnum
	tPredefinedCommonConductingEquipmentEnum *TPredefinedCommonConductingEquipmentEnum
}

func (t *TCommonConductingEquipmentEnum) IsEmpty() bool { return t.Content == "" }
func (t *TCommonConductingEquipmentEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TCommonConductingEquipmentEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TCommonConductingEquipmentEnum) Validate() error {
	{
		p := TPredefinedCommonConductingEquipmentEnum(t.Content)
		t.tPredefinedCommonConductingEquipmentEnum = &p
		if err := t.tPredefinedCommonConductingEquipmentEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tPredefinedCommonConductingEquipmentEnum = nil
		}
	}
	{
		p := TExtensionEquipmentEnum(t.Content)
		t.tExtensionEquipmentEnum = &p
		if err := t.tExtensionEquipmentEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tExtensionEquipmentEnum = nil
		}
	}
	return errors.New("не нашли member from union TCommonConductingEquipmentEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TPowerTransformerEnum ...
type TPowerTransformerEnum string

func (t *TPowerTransformerEnum) Validate() error {
	// check all enums
	switch *t {
	case TPowerTransformerEnum_PTR:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPowerTransformerEnum")
	}

	return nil
}

const (
	TPowerTransformerEnum_PTR TPowerTransformerEnum = "PTR"
)

// "SimpleType"
// base:"xs:Name"
// TTransformerWindingEnum ...
type TTransformerWindingEnum string

func (t *TTransformerWindingEnum) Validate() error {
	// check all enums
	switch *t {
	case TTransformerWindingEnum_PTW:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TTransformerWindingEnum")
	}

	return nil
}

const (
	TTransformerWindingEnum_PTW TTransformerWindingEnum = "PTW"
)

// "SimpleType"
// base:"xs:Name"
// TPredefinedGeneralEquipmentEnum ...
type TPredefinedGeneralEquipmentEnum string

func (t *TPredefinedGeneralEquipmentEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedGeneralEquipmentEnum_AXN:
	case TPredefinedGeneralEquipmentEnum_BAT:
	case TPredefinedGeneralEquipmentEnum_MOT:
	case TPredefinedGeneralEquipmentEnum_FAN:
	case TPredefinedGeneralEquipmentEnum_FIL:
	case TPredefinedGeneralEquipmentEnum_PMP:
	case TPredefinedGeneralEquipmentEnum_TNK:
	case TPredefinedGeneralEquipmentEnum_VLV:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedGeneralEquipmentEnum")
	}

	return nil
}

const (
	TPredefinedGeneralEquipmentEnum_AXN TPredefinedGeneralEquipmentEnum = "AXN"
	TPredefinedGeneralEquipmentEnum_BAT TPredefinedGeneralEquipmentEnum = "BAT"
	TPredefinedGeneralEquipmentEnum_MOT TPredefinedGeneralEquipmentEnum = "MOT"
	TPredefinedGeneralEquipmentEnum_FAN TPredefinedGeneralEquipmentEnum = "FAN"
	TPredefinedGeneralEquipmentEnum_FIL TPredefinedGeneralEquipmentEnum = "FIL"
	TPredefinedGeneralEquipmentEnum_PMP TPredefinedGeneralEquipmentEnum = "PMP"
	TPredefinedGeneralEquipmentEnum_TNK TPredefinedGeneralEquipmentEnum = "TNK"
	TPredefinedGeneralEquipmentEnum_VLV TPredefinedGeneralEquipmentEnum = "VLV"
)

// "SimpleType"
// base:"xs:Name"
// TExtensionGeneralEquipmentEnum ...
type TExtensionGeneralEquipmentEnum string

func (t *TExtensionGeneralEquipmentEnum) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^E[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TExtensionGeneralEquipmentEnum")
	}
	if len(*t) < 3 {
		return errors.New("меньше минимального 3 значение в TExtensionGeneralEquipmentEnum")
	}

	return nil
}

// "SimpleType"
// TGeneralEquipmentEnum ...
type TGeneralEquipmentEnum struct { /* UNION */
	Content                         string `xml:",chardata" json:",omitempty"`
	tExtensionGeneralEquipmentEnum  *TExtensionGeneralEquipmentEnum
	tPredefinedGeneralEquipmentEnum *TPredefinedGeneralEquipmentEnum
}

func (t *TGeneralEquipmentEnum) IsEmpty() bool { return t.Content == "" }
func (t *TGeneralEquipmentEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TGeneralEquipmentEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TGeneralEquipmentEnum) Validate() error {
	{
		p := TPredefinedGeneralEquipmentEnum(t.Content)
		t.tPredefinedGeneralEquipmentEnum = &p
		if err := t.tPredefinedGeneralEquipmentEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tPredefinedGeneralEquipmentEnum = nil
		}
	}
	{
		p := TExtensionGeneralEquipmentEnum(t.Content)
		t.tExtensionGeneralEquipmentEnum = &p
		if err := t.tExtensionGeneralEquipmentEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tExtensionGeneralEquipmentEnum = nil
		}
	}
	return errors.New("не нашли member from union TGeneralEquipmentEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TServiceSettingsNoDynEnum ...
type TServiceSettingsNoDynEnum string

func (t *TServiceSettingsNoDynEnum) Validate() error {
	// check all enums
	switch *t {
	case TServiceSettingsNoDynEnum_Conf:
	case TServiceSettingsNoDynEnum_Fix:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TServiceSettingsNoDynEnum")
	}

	return nil
}

const (
	TServiceSettingsNoDynEnum_Conf TServiceSettingsNoDynEnum = "Conf"
	TServiceSettingsNoDynEnum_Fix  TServiceSettingsNoDynEnum = "Fix"
)

// "SimpleType"
// base:"xs:Name"
// TServiceSettingsEnum ...
type TServiceSettingsEnum string

func (t *TServiceSettingsEnum) Validate() error {
	// check all enums
	switch *t {
	case TServiceSettingsEnum_Dyn:
	case TServiceSettingsEnum_Conf:
	case TServiceSettingsEnum_Fix:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TServiceSettingsEnum")
	}

	return nil
}

const (
	TServiceSettingsEnum_Dyn  TServiceSettingsEnum = "Dyn"
	TServiceSettingsEnum_Conf TServiceSettingsEnum = "Conf"
	TServiceSettingsEnum_Fix  TServiceSettingsEnum = "Fix"
)

// "SimpleType"
// base:"xs:Name"
// TRedProtEnum ...
type TRedProtEnum string

func (t *TRedProtEnum) Validate() error {
	// check all enums
	switch *t {
	case TRedProtEnum_none:
	case TRedProtEnum_hsr:
	case TRedProtEnum_prp:
	case TRedProtEnum_rstp:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TRedProtEnum")
	}

	return nil
}

const (
	TRedProtEnum_none TRedProtEnum = "none"
	TRedProtEnum_hsr  TRedProtEnum = "hsr"
	TRedProtEnum_prp  TRedProtEnum = "prp"
	TRedProtEnum_rstp TRedProtEnum = "rstp"
)

// "SimpleType"
// base:"xs:Name"
// TSMVDeliveryEnum ...
type TSMVDeliveryEnum string

func (t *TSMVDeliveryEnum) Validate() error {
	// check all enums
	switch *t {
	case TSMVDeliveryEnum_unicast:
	case TSMVDeliveryEnum_multicast:
	case TSMVDeliveryEnum_both:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TSMVDeliveryEnum")
	}

	return nil
}

const (
	TSMVDeliveryEnum_unicast   TSMVDeliveryEnum = "unicast"
	TSMVDeliveryEnum_multicast TSMVDeliveryEnum = "multicast"
	TSMVDeliveryEnum_both      TSMVDeliveryEnum = "both"
)

// "SimpleType"
// base:"xs:Name"
// TPhaseEnum ...
type TPhaseEnum string

func (t *TPhaseEnum) Validate() error {
	// check all enums
	switch *t {
	case TPhaseEnum_A:
	case TPhaseEnum_B:
	case TPhaseEnum_C:
	case TPhaseEnum_N:
	case TPhaseEnum_all:
	case TPhaseEnum_none:
	case TPhaseEnum_AB:
	case TPhaseEnum_BC:
	case TPhaseEnum_CA:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPhaseEnum")
	}

	return nil
}

const (
	TPhaseEnum_A    TPhaseEnum = "A"
	TPhaseEnum_B    TPhaseEnum = "B"
	TPhaseEnum_C    TPhaseEnum = "C"
	TPhaseEnum_N    TPhaseEnum = "N"
	TPhaseEnum_all  TPhaseEnum = "all"
	TPhaseEnum_none TPhaseEnum = "none"
	TPhaseEnum_AB   TPhaseEnum = "AB"
	TPhaseEnum_BC   TPhaseEnum = "BC"
	TPhaseEnum_CA   TPhaseEnum = "CA"
)

// "SimpleType"
// base:"xs:Name"
// TAuthenticationEnum ...
type TAuthenticationEnum string

func (t *TAuthenticationEnum) Validate() error {
	// check all enums
	switch *t {
	case TAuthenticationEnum_none:
	case TAuthenticationEnum_password:
	case TAuthenticationEnum_weak:
	case TAuthenticationEnum_strong:
	case TAuthenticationEnum_certificate:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TAuthenticationEnum")
	}

	return nil
}

const (
	TAuthenticationEnum_none        TAuthenticationEnum = "none"
	TAuthenticationEnum_password    TAuthenticationEnum = "password"
	TAuthenticationEnum_weak        TAuthenticationEnum = "weak"
	TAuthenticationEnum_strong      TAuthenticationEnum = "strong"
	TAuthenticationEnum_certificate TAuthenticationEnum = "certificate"
)

// "SimpleType"
// base:"xs:token"
// TAssociationKindEnum ...
type TAssociationKindEnum string

func (t *TAssociationKindEnum) Validate() error {
	// check all enums
	switch *t {
	case TAssociationKindEnum_preestablished:
	case TAssociationKindEnum_predefined:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TAssociationKindEnum")
	}

	return nil
}

const (
	TAssociationKindEnum_preestablished TAssociationKindEnum = "pre-established"
	TAssociationKindEnum_predefined     TAssociationKindEnum = "predefined"
)

// "SimpleType"
// base:"xs:Name"
// TLPHDEnum ...
type TLPHDEnum string

func (t *TLPHDEnum) Validate() error {
	// check all enums
	switch *t {
	case TLPHDEnum_LPHD:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TLPHDEnum")
	}

	return nil
}

const (
	TLPHDEnum_LPHD TLPHDEnum = "LPHD"
)

// "SimpleType"
// base:"xs:Name"
// TLLN0Enum ...
type TLLN0Enum string

func (t *TLLN0Enum) Validate() error {
	// check all enums
	switch *t {
	case TLLN0Enum_LLN0:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TLLN0Enum")
	}

	return nil
}

const (
	TLLN0Enum_LLN0 TLLN0Enum = "LLN0"
)

// "SimpleType"
// base:"xs:Name"
// TSystemLNGroupEnum ...
type TSystemLNGroupEnum string

func (t *TSystemLNGroupEnum) Validate() error {
	// check all enums
	switch *t {
	case TSystemLNGroupEnum_LLN0:
	case TSystemLNGroupEnum_LPHD:
	case TSystemLNGroupEnum_LCCH:
	case TSystemLNGroupEnum_LGOS:
	case TSystemLNGroupEnum_LSVS:
	case TSystemLNGroupEnum_LTIM:
	case TSystemLNGroupEnum_LTMS:
	case TSystemLNGroupEnum_LTRK:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TSystemLNGroupEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^L[A-Z]*$`, `^LLN0$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TSystemLNGroupEnum")
	}

	return nil
}

const (
	TSystemLNGroupEnum_LLN0 TSystemLNGroupEnum = "LLN0"
	TSystemLNGroupEnum_LPHD TSystemLNGroupEnum = "LPHD"
	TSystemLNGroupEnum_LCCH TSystemLNGroupEnum = "LCCH"
	TSystemLNGroupEnum_LGOS TSystemLNGroupEnum = "LGOS"
	TSystemLNGroupEnum_LSVS TSystemLNGroupEnum = "LSVS"
	TSystemLNGroupEnum_LTIM TSystemLNGroupEnum = "LTIM"
	TSystemLNGroupEnum_LTMS TSystemLNGroupEnum = "LTMS"
	TSystemLNGroupEnum_LTRK TSystemLNGroupEnum = "LTRK"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupAEnum ...
type TDomainLNGroupAEnum string

func (t *TDomainLNGroupAEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupAEnum_ANCR:
	case TDomainLNGroupAEnum_ARCO:
	case TDomainLNGroupAEnum_ARIS:
	case TDomainLNGroupAEnum_ATCC:
	case TDomainLNGroupAEnum_AVCO:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupAEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^A[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupAEnum")
	}

	return nil
}

const (
	TDomainLNGroupAEnum_ANCR TDomainLNGroupAEnum = "ANCR"
	TDomainLNGroupAEnum_ARCO TDomainLNGroupAEnum = "ARCO"
	TDomainLNGroupAEnum_ARIS TDomainLNGroupAEnum = "ARIS"
	TDomainLNGroupAEnum_ATCC TDomainLNGroupAEnum = "ATCC"
	TDomainLNGroupAEnum_AVCO TDomainLNGroupAEnum = "AVCO"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupCEnum ...
type TDomainLNGroupCEnum string

func (t *TDomainLNGroupCEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupCEnum_CALH:
	case TDomainLNGroupCEnum_CCGR:
	case TDomainLNGroupCEnum_CILO:
	case TDomainLNGroupCEnum_CPOW:
	case TDomainLNGroupCEnum_CSWI:
	case TDomainLNGroupCEnum_CSYN:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupCEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^C[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupCEnum")
	}

	return nil
}

const (
	TDomainLNGroupCEnum_CALH TDomainLNGroupCEnum = "CALH"
	TDomainLNGroupCEnum_CCGR TDomainLNGroupCEnum = "CCGR"
	TDomainLNGroupCEnum_CILO TDomainLNGroupCEnum = "CILO"
	TDomainLNGroupCEnum_CPOW TDomainLNGroupCEnum = "CPOW"
	TDomainLNGroupCEnum_CSWI TDomainLNGroupCEnum = "CSWI"
	TDomainLNGroupCEnum_CSYN TDomainLNGroupCEnum = "CSYN"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupFEnum ...
type TDomainLNGroupFEnum string

func (t *TDomainLNGroupFEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupFEnum_FCNT:
	case TDomainLNGroupFEnum_FCSD:
	case TDomainLNGroupFEnum_FFIL:
	case TDomainLNGroupFEnum_FLIM:
	case TDomainLNGroupFEnum_FPID:
	case TDomainLNGroupFEnum_FRMP:
	case TDomainLNGroupFEnum_FSPT:
	case TDomainLNGroupFEnum_FXOT:
	case TDomainLNGroupFEnum_FXUT:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupFEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^F[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupFEnum")
	}

	return nil
}

const (
	TDomainLNGroupFEnum_FCNT TDomainLNGroupFEnum = "FCNT"
	TDomainLNGroupFEnum_FCSD TDomainLNGroupFEnum = "FCSD"
	TDomainLNGroupFEnum_FFIL TDomainLNGroupFEnum = "FFIL"
	TDomainLNGroupFEnum_FLIM TDomainLNGroupFEnum = "FLIM"
	TDomainLNGroupFEnum_FPID TDomainLNGroupFEnum = "FPID"
	TDomainLNGroupFEnum_FRMP TDomainLNGroupFEnum = "FRMP"
	TDomainLNGroupFEnum_FSPT TDomainLNGroupFEnum = "FSPT"
	TDomainLNGroupFEnum_FXOT TDomainLNGroupFEnum = "FXOT"
	TDomainLNGroupFEnum_FXUT TDomainLNGroupFEnum = "FXUT"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupGEnum ...
type TDomainLNGroupGEnum string

func (t *TDomainLNGroupGEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupGEnum_GAPC:
	case TDomainLNGroupGEnum_GGIO:
	case TDomainLNGroupGEnum_GLOG:
	case TDomainLNGroupGEnum_GSAL:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupGEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^G[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupGEnum")
	}

	return nil
}

const (
	TDomainLNGroupGEnum_GAPC TDomainLNGroupGEnum = "GAPC"
	TDomainLNGroupGEnum_GGIO TDomainLNGroupGEnum = "GGIO"
	TDomainLNGroupGEnum_GLOG TDomainLNGroupGEnum = "GLOG"
	TDomainLNGroupGEnum_GSAL TDomainLNGroupGEnum = "GSAL"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupIEnum ...
type TDomainLNGroupIEnum string

func (t *TDomainLNGroupIEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupIEnum_IARC:
	case TDomainLNGroupIEnum_IHMI:
	case TDomainLNGroupIEnum_ISAF:
	case TDomainLNGroupIEnum_ITCI:
	case TDomainLNGroupIEnum_ITMI:
	case TDomainLNGroupIEnum_ITPC:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupIEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^I[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupIEnum")
	}

	return nil
}

const (
	TDomainLNGroupIEnum_IARC TDomainLNGroupIEnum = "IARC"
	TDomainLNGroupIEnum_IHMI TDomainLNGroupIEnum = "IHMI"
	TDomainLNGroupIEnum_ISAF TDomainLNGroupIEnum = "ISAF"
	TDomainLNGroupIEnum_ITCI TDomainLNGroupIEnum = "ITCI"
	TDomainLNGroupIEnum_ITMI TDomainLNGroupIEnum = "ITMI"
	TDomainLNGroupIEnum_ITPC TDomainLNGroupIEnum = "ITPC"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupKEnum ...
type TDomainLNGroupKEnum string

func (t *TDomainLNGroupKEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupKEnum_KFAN:
	case TDomainLNGroupKEnum_KFIL:
	case TDomainLNGroupKEnum_KPMP:
	case TDomainLNGroupKEnum_KTNK:
	case TDomainLNGroupKEnum_KVLV:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupKEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^K[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupKEnum")
	}

	return nil
}

const (
	TDomainLNGroupKEnum_KFAN TDomainLNGroupKEnum = "KFAN"
	TDomainLNGroupKEnum_KFIL TDomainLNGroupKEnum = "KFIL"
	TDomainLNGroupKEnum_KPMP TDomainLNGroupKEnum = "KPMP"
	TDomainLNGroupKEnum_KTNK TDomainLNGroupKEnum = "KTNK"
	TDomainLNGroupKEnum_KVLV TDomainLNGroupKEnum = "KVLV"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupMEnum ...
type TDomainLNGroupMEnum string

func (t *TDomainLNGroupMEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupMEnum_MDIF:
	case TDomainLNGroupMEnum_MENV:
	case TDomainLNGroupMEnum_MFLK:
	case TDomainLNGroupMEnum_MHAI:
	case TDomainLNGroupMEnum_MHAN:
	case TDomainLNGroupMEnum_MHYD:
	case TDomainLNGroupMEnum_MMDC:
	case TDomainLNGroupMEnum_MMET:
	case TDomainLNGroupMEnum_MMTN:
	case TDomainLNGroupMEnum_MMTR:
	case TDomainLNGroupMEnum_MMXN:
	case TDomainLNGroupMEnum_MMXU:
	case TDomainLNGroupMEnum_MSQI:
	case TDomainLNGroupMEnum_MSTA:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupMEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^M[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupMEnum")
	}

	return nil
}

const (
	TDomainLNGroupMEnum_MDIF TDomainLNGroupMEnum = "MDIF"
	TDomainLNGroupMEnum_MENV TDomainLNGroupMEnum = "MENV"
	TDomainLNGroupMEnum_MFLK TDomainLNGroupMEnum = "MFLK"
	TDomainLNGroupMEnum_MHAI TDomainLNGroupMEnum = "MHAI"
	TDomainLNGroupMEnum_MHAN TDomainLNGroupMEnum = "MHAN"
	TDomainLNGroupMEnum_MHYD TDomainLNGroupMEnum = "MHYD"
	TDomainLNGroupMEnum_MMDC TDomainLNGroupMEnum = "MMDC"
	TDomainLNGroupMEnum_MMET TDomainLNGroupMEnum = "MMET"
	TDomainLNGroupMEnum_MMTN TDomainLNGroupMEnum = "MMTN"
	TDomainLNGroupMEnum_MMTR TDomainLNGroupMEnum = "MMTR"
	TDomainLNGroupMEnum_MMXN TDomainLNGroupMEnum = "MMXN"
	TDomainLNGroupMEnum_MMXU TDomainLNGroupMEnum = "MMXU"
	TDomainLNGroupMEnum_MSQI TDomainLNGroupMEnum = "MSQI"
	TDomainLNGroupMEnum_MSTA TDomainLNGroupMEnum = "MSTA"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupPEnum ...
type TDomainLNGroupPEnum string

func (t *TDomainLNGroupPEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupPEnum_PDIF:
	case TDomainLNGroupPEnum_PDIR:
	case TDomainLNGroupPEnum_PDIS:
	case TDomainLNGroupPEnum_PDOP:
	case TDomainLNGroupPEnum_PDUP:
	case TDomainLNGroupPEnum_PFRC:
	case TDomainLNGroupPEnum_PHAR:
	case TDomainLNGroupPEnum_PHIZ:
	case TDomainLNGroupPEnum_PIOC:
	case TDomainLNGroupPEnum_PMRI:
	case TDomainLNGroupPEnum_PMSS:
	case TDomainLNGroupPEnum_POPF:
	case TDomainLNGroupPEnum_PPAM:
	case TDomainLNGroupPEnum_PRTR:
	case TDomainLNGroupPEnum_PSCH:
	case TDomainLNGroupPEnum_PSDE:
	case TDomainLNGroupPEnum_PTEF:
	case TDomainLNGroupPEnum_PTHF:
	case TDomainLNGroupPEnum_PTOC:
	case TDomainLNGroupPEnum_PTOF:
	case TDomainLNGroupPEnum_PTOV:
	case TDomainLNGroupPEnum_PTRC:
	case TDomainLNGroupPEnum_PTTR:
	case TDomainLNGroupPEnum_PTUC:
	case TDomainLNGroupPEnum_PTUF:
	case TDomainLNGroupPEnum_PTUV:
	case TDomainLNGroupPEnum_PUPF:
	case TDomainLNGroupPEnum_PVOC:
	case TDomainLNGroupPEnum_PVPH:
	case TDomainLNGroupPEnum_PZSU:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupPEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^P[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupPEnum")
	}

	return nil
}

const (
	TDomainLNGroupPEnum_PDIF TDomainLNGroupPEnum = "PDIF"
	TDomainLNGroupPEnum_PDIR TDomainLNGroupPEnum = "PDIR"
	TDomainLNGroupPEnum_PDIS TDomainLNGroupPEnum = "PDIS"
	TDomainLNGroupPEnum_PDOP TDomainLNGroupPEnum = "PDOP"
	TDomainLNGroupPEnum_PDUP TDomainLNGroupPEnum = "PDUP"
	TDomainLNGroupPEnum_PFRC TDomainLNGroupPEnum = "PFRC"
	TDomainLNGroupPEnum_PHAR TDomainLNGroupPEnum = "PHAR"
	TDomainLNGroupPEnum_PHIZ TDomainLNGroupPEnum = "PHIZ"
	TDomainLNGroupPEnum_PIOC TDomainLNGroupPEnum = "PIOC"
	TDomainLNGroupPEnum_PMRI TDomainLNGroupPEnum = "PMRI"
	TDomainLNGroupPEnum_PMSS TDomainLNGroupPEnum = "PMSS"
	TDomainLNGroupPEnum_POPF TDomainLNGroupPEnum = "POPF"
	TDomainLNGroupPEnum_PPAM TDomainLNGroupPEnum = "PPAM"
	TDomainLNGroupPEnum_PRTR TDomainLNGroupPEnum = "PRTR"
	TDomainLNGroupPEnum_PSCH TDomainLNGroupPEnum = "PSCH"
	TDomainLNGroupPEnum_PSDE TDomainLNGroupPEnum = "PSDE"
	TDomainLNGroupPEnum_PTEF TDomainLNGroupPEnum = "PTEF"
	TDomainLNGroupPEnum_PTHF TDomainLNGroupPEnum = "PTHF"
	TDomainLNGroupPEnum_PTOC TDomainLNGroupPEnum = "PTOC"
	TDomainLNGroupPEnum_PTOF TDomainLNGroupPEnum = "PTOF"
	TDomainLNGroupPEnum_PTOV TDomainLNGroupPEnum = "PTOV"
	TDomainLNGroupPEnum_PTRC TDomainLNGroupPEnum = "PTRC"
	TDomainLNGroupPEnum_PTTR TDomainLNGroupPEnum = "PTTR"
	TDomainLNGroupPEnum_PTUC TDomainLNGroupPEnum = "PTUC"
	TDomainLNGroupPEnum_PTUF TDomainLNGroupPEnum = "PTUF"
	TDomainLNGroupPEnum_PTUV TDomainLNGroupPEnum = "PTUV"
	TDomainLNGroupPEnum_PUPF TDomainLNGroupPEnum = "PUPF"
	TDomainLNGroupPEnum_PVOC TDomainLNGroupPEnum = "PVOC"
	TDomainLNGroupPEnum_PVPH TDomainLNGroupPEnum = "PVPH"
	TDomainLNGroupPEnum_PZSU TDomainLNGroupPEnum = "PZSU"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupQEnum ...
type TDomainLNGroupQEnum string

func (t *TDomainLNGroupQEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupQEnum_QFVR:
	case TDomainLNGroupQEnum_QITR:
	case TDomainLNGroupQEnum_QIUB:
	case TDomainLNGroupQEnum_QVTR:
	case TDomainLNGroupQEnum_QVUB:
	case TDomainLNGroupQEnum_QVVR:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupQEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^Q[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupQEnum")
	}

	return nil
}

const (
	TDomainLNGroupQEnum_QFVR TDomainLNGroupQEnum = "QFVR"
	TDomainLNGroupQEnum_QITR TDomainLNGroupQEnum = "QITR"
	TDomainLNGroupQEnum_QIUB TDomainLNGroupQEnum = "QIUB"
	TDomainLNGroupQEnum_QVTR TDomainLNGroupQEnum = "QVTR"
	TDomainLNGroupQEnum_QVUB TDomainLNGroupQEnum = "QVUB"
	TDomainLNGroupQEnum_QVVR TDomainLNGroupQEnum = "QVVR"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupREnum ...
type TDomainLNGroupREnum string

func (t *TDomainLNGroupREnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupREnum_RADR:
	case TDomainLNGroupREnum_RBDR:
	case TDomainLNGroupREnum_RBRF:
	case TDomainLNGroupREnum_RDIR:
	case TDomainLNGroupREnum_RDRE:
	case TDomainLNGroupREnum_RDRS:
	case TDomainLNGroupREnum_RFLO:
	case TDomainLNGroupREnum_RMXU:
	case TDomainLNGroupREnum_RPSB:
	case TDomainLNGroupREnum_RREC:
	case TDomainLNGroupREnum_RSYN:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupREnum")
	}

	var checkPattern bool
	for _, p := range []string{`^R[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupREnum")
	}

	return nil
}

const (
	TDomainLNGroupREnum_RADR TDomainLNGroupREnum = "RADR"
	TDomainLNGroupREnum_RBDR TDomainLNGroupREnum = "RBDR"
	TDomainLNGroupREnum_RBRF TDomainLNGroupREnum = "RBRF"
	TDomainLNGroupREnum_RDIR TDomainLNGroupREnum = "RDIR"
	TDomainLNGroupREnum_RDRE TDomainLNGroupREnum = "RDRE"
	TDomainLNGroupREnum_RDRS TDomainLNGroupREnum = "RDRS"
	TDomainLNGroupREnum_RFLO TDomainLNGroupREnum = "RFLO"
	TDomainLNGroupREnum_RMXU TDomainLNGroupREnum = "RMXU"
	TDomainLNGroupREnum_RPSB TDomainLNGroupREnum = "RPSB"
	TDomainLNGroupREnum_RREC TDomainLNGroupREnum = "RREC"
	TDomainLNGroupREnum_RSYN TDomainLNGroupREnum = "RSYN"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupSEnum ...
type TDomainLNGroupSEnum string

func (t *TDomainLNGroupSEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupSEnum_SARC:
	case TDomainLNGroupSEnum_SCBR:
	case TDomainLNGroupSEnum_SIMG:
	case TDomainLNGroupSEnum_SIML:
	case TDomainLNGroupSEnum_SLTC:
	case TDomainLNGroupSEnum_SOPM:
	case TDomainLNGroupSEnum_SPDC:
	case TDomainLNGroupSEnum_SPTR:
	case TDomainLNGroupSEnum_SSWI:
	case TDomainLNGroupSEnum_STMP:
	case TDomainLNGroupSEnum_SVBR:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupSEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^S[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupSEnum")
	}

	return nil
}

const (
	TDomainLNGroupSEnum_SARC TDomainLNGroupSEnum = "SARC"
	TDomainLNGroupSEnum_SCBR TDomainLNGroupSEnum = "SCBR"
	TDomainLNGroupSEnum_SIMG TDomainLNGroupSEnum = "SIMG"
	TDomainLNGroupSEnum_SIML TDomainLNGroupSEnum = "SIML"
	TDomainLNGroupSEnum_SLTC TDomainLNGroupSEnum = "SLTC"
	TDomainLNGroupSEnum_SOPM TDomainLNGroupSEnum = "SOPM"
	TDomainLNGroupSEnum_SPDC TDomainLNGroupSEnum = "SPDC"
	TDomainLNGroupSEnum_SPTR TDomainLNGroupSEnum = "SPTR"
	TDomainLNGroupSEnum_SSWI TDomainLNGroupSEnum = "SSWI"
	TDomainLNGroupSEnum_STMP TDomainLNGroupSEnum = "STMP"
	TDomainLNGroupSEnum_SVBR TDomainLNGroupSEnum = "SVBR"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupTEnum ...
type TDomainLNGroupTEnum string

func (t *TDomainLNGroupTEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupTEnum_TANG:
	case TDomainLNGroupTEnum_TAXD:
	case TDomainLNGroupTEnum_TCTR:
	case TDomainLNGroupTEnum_TDST:
	case TDomainLNGroupTEnum_TFLW:
	case TDomainLNGroupTEnum_TFRQ:
	case TDomainLNGroupTEnum_TGSN:
	case TDomainLNGroupTEnum_THUM:
	case TDomainLNGroupTEnum_TLVL:
	case TDomainLNGroupTEnum_TMGF:
	case TDomainLNGroupTEnum_TMVM:
	case TDomainLNGroupTEnum_TPOS:
	case TDomainLNGroupTEnum_TPRS:
	case TDomainLNGroupTEnum_TRTN:
	case TDomainLNGroupTEnum_TSND:
	case TDomainLNGroupTEnum_TTMP:
	case TDomainLNGroupTEnum_TTNS:
	case TDomainLNGroupTEnum_TVBR:
	case TDomainLNGroupTEnum_TVTR:
	case TDomainLNGroupTEnum_TWPH:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupTEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^T[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupTEnum")
	}

	return nil
}

const (
	TDomainLNGroupTEnum_TANG TDomainLNGroupTEnum = "TANG"
	TDomainLNGroupTEnum_TAXD TDomainLNGroupTEnum = "TAXD"
	TDomainLNGroupTEnum_TCTR TDomainLNGroupTEnum = "TCTR"
	TDomainLNGroupTEnum_TDST TDomainLNGroupTEnum = "TDST"
	TDomainLNGroupTEnum_TFLW TDomainLNGroupTEnum = "TFLW"
	TDomainLNGroupTEnum_TFRQ TDomainLNGroupTEnum = "TFRQ"
	TDomainLNGroupTEnum_TGSN TDomainLNGroupTEnum = "TGSN"
	TDomainLNGroupTEnum_THUM TDomainLNGroupTEnum = "THUM"
	TDomainLNGroupTEnum_TLVL TDomainLNGroupTEnum = "TLVL"
	TDomainLNGroupTEnum_TMGF TDomainLNGroupTEnum = "TMGF"
	TDomainLNGroupTEnum_TMVM TDomainLNGroupTEnum = "TMVM"
	TDomainLNGroupTEnum_TPOS TDomainLNGroupTEnum = "TPOS"
	TDomainLNGroupTEnum_TPRS TDomainLNGroupTEnum = "TPRS"
	TDomainLNGroupTEnum_TRTN TDomainLNGroupTEnum = "TRTN"
	TDomainLNGroupTEnum_TSND TDomainLNGroupTEnum = "TSND"
	TDomainLNGroupTEnum_TTMP TDomainLNGroupTEnum = "TTMP"
	TDomainLNGroupTEnum_TTNS TDomainLNGroupTEnum = "TTNS"
	TDomainLNGroupTEnum_TVBR TDomainLNGroupTEnum = "TVBR"
	TDomainLNGroupTEnum_TVTR TDomainLNGroupTEnum = "TVTR"
	TDomainLNGroupTEnum_TWPH TDomainLNGroupTEnum = "TWPH"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupXEnum ...
type TDomainLNGroupXEnum string

func (t *TDomainLNGroupXEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupXEnum_XCBR:
	case TDomainLNGroupXEnum_XSWI:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupXEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^X[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupXEnum")
	}

	return nil
}

const (
	TDomainLNGroupXEnum_XCBR TDomainLNGroupXEnum = "XCBR"
	TDomainLNGroupXEnum_XSWI TDomainLNGroupXEnum = "XSWI"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupYEnum ...
type TDomainLNGroupYEnum string

func (t *TDomainLNGroupYEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupYEnum_YEFN:
	case TDomainLNGroupYEnum_YLTC:
	case TDomainLNGroupYEnum_YPSH:
	case TDomainLNGroupYEnum_YPTR:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupYEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^Y[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupYEnum")
	}

	return nil
}

const (
	TDomainLNGroupYEnum_YEFN TDomainLNGroupYEnum = "YEFN"
	TDomainLNGroupYEnum_YLTC TDomainLNGroupYEnum = "YLTC"
	TDomainLNGroupYEnum_YPSH TDomainLNGroupYEnum = "YPSH"
	TDomainLNGroupYEnum_YPTR TDomainLNGroupYEnum = "YPTR"
)

// "SimpleType"
// base:"xs:Name"
// TDomainLNGroupZEnum ...
type TDomainLNGroupZEnum string

func (t *TDomainLNGroupZEnum) Validate() error {
	// check all enums
	switch *t {
	case TDomainLNGroupZEnum_ZAXN:
	case TDomainLNGroupZEnum_ZBAT:
	case TDomainLNGroupZEnum_ZBSH:
	case TDomainLNGroupZEnum_ZCAB:
	case TDomainLNGroupZEnum_ZCAP:
	case TDomainLNGroupZEnum_ZCON:
	case TDomainLNGroupZEnum_ZGEN:
	case TDomainLNGroupZEnum_ZGIL:
	case TDomainLNGroupZEnum_ZLIN:
	case TDomainLNGroupZEnum_ZMOT:
	case TDomainLNGroupZEnum_ZREA:
	case TDomainLNGroupZEnum_ZRES:
	case TDomainLNGroupZEnum_ZRRC:
	case TDomainLNGroupZEnum_ZSAR:
	case TDomainLNGroupZEnum_ZSCR:
	case TDomainLNGroupZEnum_ZSMC:
	case TDomainLNGroupZEnum_ZTCF:
	case TDomainLNGroupZEnum_ZTCR:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TDomainLNGroupZEnum")
	}

	var checkPattern bool
	for _, p := range []string{`^Z[A-Z]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TDomainLNGroupZEnum")
	}

	return nil
}

const (
	TDomainLNGroupZEnum_ZAXN TDomainLNGroupZEnum = "ZAXN"
	TDomainLNGroupZEnum_ZBAT TDomainLNGroupZEnum = "ZBAT"
	TDomainLNGroupZEnum_ZBSH TDomainLNGroupZEnum = "ZBSH"
	TDomainLNGroupZEnum_ZCAB TDomainLNGroupZEnum = "ZCAB"
	TDomainLNGroupZEnum_ZCAP TDomainLNGroupZEnum = "ZCAP"
	TDomainLNGroupZEnum_ZCON TDomainLNGroupZEnum = "ZCON"
	TDomainLNGroupZEnum_ZGEN TDomainLNGroupZEnum = "ZGEN"
	TDomainLNGroupZEnum_ZGIL TDomainLNGroupZEnum = "ZGIL"
	TDomainLNGroupZEnum_ZLIN TDomainLNGroupZEnum = "ZLIN"
	TDomainLNGroupZEnum_ZMOT TDomainLNGroupZEnum = "ZMOT"
	TDomainLNGroupZEnum_ZREA TDomainLNGroupZEnum = "ZREA"
	TDomainLNGroupZEnum_ZRES TDomainLNGroupZEnum = "ZRES"
	TDomainLNGroupZEnum_ZRRC TDomainLNGroupZEnum = "ZRRC"
	TDomainLNGroupZEnum_ZSAR TDomainLNGroupZEnum = "ZSAR"
	TDomainLNGroupZEnum_ZSCR TDomainLNGroupZEnum = "ZSCR"
	TDomainLNGroupZEnum_ZSMC TDomainLNGroupZEnum = "ZSMC"
	TDomainLNGroupZEnum_ZTCF TDomainLNGroupZEnum = "ZTCF"
	TDomainLNGroupZEnum_ZTCR TDomainLNGroupZEnum = "ZTCR"
)

// "SimpleType"
// TDomainLNEnum ...
type TDomainLNEnum struct { /* UNION */
	Content             string `xml:",chardata" json:",omitempty"`
	tDomainLNGroupIEnum *TDomainLNGroupIEnum
	tDomainLNGroupMEnum *TDomainLNGroupMEnum
	tDomainLNGroupXEnum *TDomainLNGroupXEnum
	tDomainLNGroupGEnum *TDomainLNGroupGEnum
	tDomainLNGroupQEnum *TDomainLNGroupQEnum
	tDomainLNGroupAEnum *TDomainLNGroupAEnum
	tDomainLNGroupSEnum *TDomainLNGroupSEnum
	tDomainLNGroupREnum *TDomainLNGroupREnum
	tDomainLNGroupFEnum *TDomainLNGroupFEnum
	tDomainLNGroupKEnum *TDomainLNGroupKEnum
	tDomainLNGroupPEnum *TDomainLNGroupPEnum
	tDomainLNGroupTEnum *TDomainLNGroupTEnum
	tDomainLNGroupYEnum *TDomainLNGroupYEnum
	tDomainLNGroupZEnum *TDomainLNGroupZEnum
	tDomainLNGroupCEnum *TDomainLNGroupCEnum
}

func (t *TDomainLNEnum) IsEmpty() bool { return t.Content == "" }
func (t *TDomainLNEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TDomainLNEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TDomainLNEnum) Validate() error {
	{
		p := TDomainLNGroupREnum(t.Content)
		t.tDomainLNGroupREnum = &p
		if err := t.tDomainLNGroupREnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupREnum = nil
		}
	}
	{
		p := TDomainLNGroupSEnum(t.Content)
		t.tDomainLNGroupSEnum = &p
		if err := t.tDomainLNGroupSEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupSEnum = nil
		}
	}
	{
		p := TDomainLNGroupKEnum(t.Content)
		t.tDomainLNGroupKEnum = &p
		if err := t.tDomainLNGroupKEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupKEnum = nil
		}
	}
	{
		p := TDomainLNGroupPEnum(t.Content)
		t.tDomainLNGroupPEnum = &p
		if err := t.tDomainLNGroupPEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupPEnum = nil
		}
	}
	{
		p := TDomainLNGroupTEnum(t.Content)
		t.tDomainLNGroupTEnum = &p
		if err := t.tDomainLNGroupTEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupTEnum = nil
		}
	}
	{
		p := TDomainLNGroupYEnum(t.Content)
		t.tDomainLNGroupYEnum = &p
		if err := t.tDomainLNGroupYEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupYEnum = nil
		}
	}
	{
		p := TDomainLNGroupZEnum(t.Content)
		t.tDomainLNGroupZEnum = &p
		if err := t.tDomainLNGroupZEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupZEnum = nil
		}
	}
	{
		p := TDomainLNGroupCEnum(t.Content)
		t.tDomainLNGroupCEnum = &p
		if err := t.tDomainLNGroupCEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupCEnum = nil
		}
	}
	{
		p := TDomainLNGroupFEnum(t.Content)
		t.tDomainLNGroupFEnum = &p
		if err := t.tDomainLNGroupFEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupFEnum = nil
		}
	}
	{
		p := TDomainLNGroupMEnum(t.Content)
		t.tDomainLNGroupMEnum = &p
		if err := t.tDomainLNGroupMEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupMEnum = nil
		}
	}
	{
		p := TDomainLNGroupXEnum(t.Content)
		t.tDomainLNGroupXEnum = &p
		if err := t.tDomainLNGroupXEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupXEnum = nil
		}
	}
	{
		p := TDomainLNGroupGEnum(t.Content)
		t.tDomainLNGroupGEnum = &p
		if err := t.tDomainLNGroupGEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupGEnum = nil
		}
	}
	{
		p := TDomainLNGroupIEnum(t.Content)
		t.tDomainLNGroupIEnum = &p
		if err := t.tDomainLNGroupIEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupIEnum = nil
		}
	}
	{
		p := TDomainLNGroupAEnum(t.Content)
		t.tDomainLNGroupAEnum = &p
		if err := t.tDomainLNGroupAEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupAEnum = nil
		}
	}
	{
		p := TDomainLNGroupQEnum(t.Content)
		t.tDomainLNGroupQEnum = &p
		if err := t.tDomainLNGroupQEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNGroupQEnum = nil
		}
	}
	return errors.New("не нашли member from union TDomainLNEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// TPredefinedLNClassEnum ...
type TPredefinedLNClassEnum struct { /* UNION */
	Content            string `xml:",chardata" json:",omitempty"`
	tSystemLNGroupEnum *TSystemLNGroupEnum
	tDomainLNEnum      *TDomainLNEnum
}

func (t *TPredefinedLNClassEnum) IsEmpty() bool { return t.Content == "" }
func (t *TPredefinedLNClassEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TPredefinedLNClassEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TPredefinedLNClassEnum) Validate() error {
	{
		p := TSystemLNGroupEnum(t.Content)
		t.tSystemLNGroupEnum = &p
		if err := t.tSystemLNGroupEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tSystemLNGroupEnum = nil
		}
	}
	{
		p := TDomainLNEnum{Content: t.Content}
		t.tDomainLNEnum = &p
		if err := t.tDomainLNEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tDomainLNEnum = nil
		}
	}
	return errors.New("не нашли member from union TPredefinedLNClassEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TExtensionLNClassEnum ...
type TExtensionLNClassEnum string

func (t *TExtensionLNClassEnum) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Z]+$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TExtensionLNClassEnum")
	}

	return nil
}

// "SimpleType"
// TLNClassEnum ...
type TLNClassEnum struct { /* UNION */
	Content                string `xml:",chardata" json:",omitempty"`
	tPredefinedLNClassEnum *TPredefinedLNClassEnum
	tExtensionLNClassEnum  *TExtensionLNClassEnum
}

func (t *TLNClassEnum) IsEmpty() bool { return t.Content == "" }
func (t *TLNClassEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TLNClassEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TLNClassEnum) Validate() error {
	{
		p := TPredefinedLNClassEnum{Content: t.Content}
		t.tPredefinedLNClassEnum = &p
		if err := t.tPredefinedLNClassEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tPredefinedLNClassEnum = nil
		}
	}
	{
		p := TExtensionLNClassEnum(t.Content)
		t.tExtensionLNClassEnum = &p
		if err := t.tExtensionLNClassEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tExtensionLNClassEnum = nil
		}
	}
	return errors.New("не нашли member from union TLNClassEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TPredefinedCDCEnum ...
type TPredefinedCDCEnum string

func (t *TPredefinedCDCEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedCDCEnum_SPS:
	case TPredefinedCDCEnum_DPS:
	case TPredefinedCDCEnum_INS:
	case TPredefinedCDCEnum_ENS:
	case TPredefinedCDCEnum_ACT:
	case TPredefinedCDCEnum_ACD:
	case TPredefinedCDCEnum_SEC:
	case TPredefinedCDCEnum_BCR:
	case TPredefinedCDCEnum_HST:
	case TPredefinedCDCEnum_VSS:
	case TPredefinedCDCEnum_MV:
	case TPredefinedCDCEnum_CMV:
	case TPredefinedCDCEnum_SAV:
	case TPredefinedCDCEnum_WYE:
	case TPredefinedCDCEnum_DEL:
	case TPredefinedCDCEnum_SEQ:
	case TPredefinedCDCEnum_HMV:
	case TPredefinedCDCEnum_HWYE:
	case TPredefinedCDCEnum_HDEL:
	case TPredefinedCDCEnum_SPC:
	case TPredefinedCDCEnum_DPC:
	case TPredefinedCDCEnum_INC:
	case TPredefinedCDCEnum_ENC:
	case TPredefinedCDCEnum_BSC:
	case TPredefinedCDCEnum_ISC:
	case TPredefinedCDCEnum_APC:
	case TPredefinedCDCEnum_BAC:
	case TPredefinedCDCEnum_SPG:
	case TPredefinedCDCEnum_ING:
	case TPredefinedCDCEnum_ENG:
	case TPredefinedCDCEnum_ORG:
	case TPredefinedCDCEnum_TSG:
	case TPredefinedCDCEnum_CUG:
	case TPredefinedCDCEnum_VSG:
	case TPredefinedCDCEnum_ASG:
	case TPredefinedCDCEnum_CURVE:
	case TPredefinedCDCEnum_CSG:
	case TPredefinedCDCEnum_DPL:
	case TPredefinedCDCEnum_LPL:
	case TPredefinedCDCEnum_CSD:
	case TPredefinedCDCEnum_CST:
	case TPredefinedCDCEnum_BTS:
	case TPredefinedCDCEnum_UTS:
	case TPredefinedCDCEnum_LTS:
	case TPredefinedCDCEnum_GTS:
	case TPredefinedCDCEnum_MTS:
	case TPredefinedCDCEnum_NTS:
	case TPredefinedCDCEnum_STS:
	case TPredefinedCDCEnum_CTS:
	case TPredefinedCDCEnum_OTS:
	case TPredefinedCDCEnum_VSD:
	case TPredefinedCDCEnum_ORS:
	case TPredefinedCDCEnum_TCS:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedCDCEnum")
	}

	return nil
}

const (
	TPredefinedCDCEnum_SPS   TPredefinedCDCEnum = "SPS"
	TPredefinedCDCEnum_DPS   TPredefinedCDCEnum = "DPS"
	TPredefinedCDCEnum_INS   TPredefinedCDCEnum = "INS"
	TPredefinedCDCEnum_ENS   TPredefinedCDCEnum = "ENS"
	TPredefinedCDCEnum_ACT   TPredefinedCDCEnum = "ACT"
	TPredefinedCDCEnum_ACD   TPredefinedCDCEnum = "ACD"
	TPredefinedCDCEnum_SEC   TPredefinedCDCEnum = "SEC"
	TPredefinedCDCEnum_BCR   TPredefinedCDCEnum = "BCR"
	TPredefinedCDCEnum_HST   TPredefinedCDCEnum = "HST"
	TPredefinedCDCEnum_VSS   TPredefinedCDCEnum = "VSS"
	TPredefinedCDCEnum_MV    TPredefinedCDCEnum = "MV"
	TPredefinedCDCEnum_CMV   TPredefinedCDCEnum = "CMV"
	TPredefinedCDCEnum_SAV   TPredefinedCDCEnum = "SAV"
	TPredefinedCDCEnum_WYE   TPredefinedCDCEnum = "WYE"
	TPredefinedCDCEnum_DEL   TPredefinedCDCEnum = "DEL"
	TPredefinedCDCEnum_SEQ   TPredefinedCDCEnum = "SEQ"
	TPredefinedCDCEnum_HMV   TPredefinedCDCEnum = "HMV"
	TPredefinedCDCEnum_HWYE  TPredefinedCDCEnum = "HWYE"
	TPredefinedCDCEnum_HDEL  TPredefinedCDCEnum = "HDEL"
	TPredefinedCDCEnum_SPC   TPredefinedCDCEnum = "SPC"
	TPredefinedCDCEnum_DPC   TPredefinedCDCEnum = "DPC"
	TPredefinedCDCEnum_INC   TPredefinedCDCEnum = "INC"
	TPredefinedCDCEnum_ENC   TPredefinedCDCEnum = "ENC"
	TPredefinedCDCEnum_BSC   TPredefinedCDCEnum = "BSC"
	TPredefinedCDCEnum_ISC   TPredefinedCDCEnum = "ISC"
	TPredefinedCDCEnum_APC   TPredefinedCDCEnum = "APC"
	TPredefinedCDCEnum_BAC   TPredefinedCDCEnum = "BAC"
	TPredefinedCDCEnum_SPG   TPredefinedCDCEnum = "SPG"
	TPredefinedCDCEnum_ING   TPredefinedCDCEnum = "ING"
	TPredefinedCDCEnum_ENG   TPredefinedCDCEnum = "ENG"
	TPredefinedCDCEnum_ORG   TPredefinedCDCEnum = "ORG"
	TPredefinedCDCEnum_TSG   TPredefinedCDCEnum = "TSG"
	TPredefinedCDCEnum_CUG   TPredefinedCDCEnum = "CUG"
	TPredefinedCDCEnum_VSG   TPredefinedCDCEnum = "VSG"
	TPredefinedCDCEnum_ASG   TPredefinedCDCEnum = "ASG"
	TPredefinedCDCEnum_CURVE TPredefinedCDCEnum = "CURVE"
	TPredefinedCDCEnum_CSG   TPredefinedCDCEnum = "CSG"
	TPredefinedCDCEnum_DPL   TPredefinedCDCEnum = "DPL"
	TPredefinedCDCEnum_LPL   TPredefinedCDCEnum = "LPL"
	TPredefinedCDCEnum_CSD   TPredefinedCDCEnum = "CSD"
	TPredefinedCDCEnum_CST   TPredefinedCDCEnum = "CST"
	TPredefinedCDCEnum_BTS   TPredefinedCDCEnum = "BTS"
	TPredefinedCDCEnum_UTS   TPredefinedCDCEnum = "UTS"
	TPredefinedCDCEnum_LTS   TPredefinedCDCEnum = "LTS"
	TPredefinedCDCEnum_GTS   TPredefinedCDCEnum = "GTS"
	TPredefinedCDCEnum_MTS   TPredefinedCDCEnum = "MTS"
	TPredefinedCDCEnum_NTS   TPredefinedCDCEnum = "NTS"
	TPredefinedCDCEnum_STS   TPredefinedCDCEnum = "STS"
	TPredefinedCDCEnum_CTS   TPredefinedCDCEnum = "CTS"
	TPredefinedCDCEnum_OTS   TPredefinedCDCEnum = "OTS"
	TPredefinedCDCEnum_VSD   TPredefinedCDCEnum = "VSD"
	TPredefinedCDCEnum_ORS   TPredefinedCDCEnum = "ORS"
	TPredefinedCDCEnum_TCS   TPredefinedCDCEnum = "TCS"
)

// "SimpleType"
// base:"xs:Name"
// TExtensionCDCEnum ...
type TExtensionCDCEnum string

func (t *TExtensionCDCEnum) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Za-z]+$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TExtensionCDCEnum")
	}
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TExtensionCDCEnum")
	}
	if len(*t) > 5 {
		return errors.New("больше макс значения 5 в TExtensionCDCEnum")
	}

	return nil
}

// "SimpleType"
// base:"tPredefinedCDCEnum"
// TCDCEnum ...
type TCDCEnum string

func (t *TCDCEnum) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TFCEnum ...
type TFCEnum string

func (t *TFCEnum) Validate() error {
	// check all enums
	switch *t {
	case TFCEnum_ST:
	case TFCEnum_MX:
	case TFCEnum_CO:
	case TFCEnum_SP:
	case TFCEnum_SG:
	case TFCEnum_SE:
	case TFCEnum_SV:
	case TFCEnum_CF:
	case TFCEnum_DC:
	case TFCEnum_EX:
	case TFCEnum_SR:
	case TFCEnum_BL:
	case TFCEnum_OR:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TFCEnum")
	}

	return nil
}

const (
	TFCEnum_ST TFCEnum = "ST"
	TFCEnum_MX TFCEnum = "MX"
	TFCEnum_CO TFCEnum = "CO"
	TFCEnum_SP TFCEnum = "SP"
	TFCEnum_SG TFCEnum = "SG"
	TFCEnum_SE TFCEnum = "SE"
	TFCEnum_SV TFCEnum = "SV"
	TFCEnum_CF TFCEnum = "CF"
	TFCEnum_DC TFCEnum = "DC"
	TFCEnum_EX TFCEnum = "EX"
	TFCEnum_SR TFCEnum = "SR"
	TFCEnum_BL TFCEnum = "BL"
	TFCEnum_OR TFCEnum = "OR"
)

// "SimpleType"
// base:"xs:Name"
// TPredefinedBasicTypeEnum ...
type TPredefinedBasicTypeEnum string

func (t *TPredefinedBasicTypeEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedBasicTypeEnum_BOOLEAN:
	case TPredefinedBasicTypeEnum_INT8:
	case TPredefinedBasicTypeEnum_INT16:
	case TPredefinedBasicTypeEnum_INT24:
	case TPredefinedBasicTypeEnum_INT32:
	case TPredefinedBasicTypeEnum_INT64:
	case TPredefinedBasicTypeEnum_INT128:
	case TPredefinedBasicTypeEnum_INT8U:
	case TPredefinedBasicTypeEnum_INT16U:
	case TPredefinedBasicTypeEnum_INT24U:
	case TPredefinedBasicTypeEnum_INT32U:
	case TPredefinedBasicTypeEnum_FLOAT32:
	case TPredefinedBasicTypeEnum_FLOAT64:
	case TPredefinedBasicTypeEnum_Enum:
	case TPredefinedBasicTypeEnum_Dbpos:
	case TPredefinedBasicTypeEnum_Tcmd:
	case TPredefinedBasicTypeEnum_Quality:
	case TPredefinedBasicTypeEnum_Timestamp:
	case TPredefinedBasicTypeEnum_VisString32:
	case TPredefinedBasicTypeEnum_VisString64:
	case TPredefinedBasicTypeEnum_VisString65:
	case TPredefinedBasicTypeEnum_VisString129:
	case TPredefinedBasicTypeEnum_VisString255:
	case TPredefinedBasicTypeEnum_Octet64:
	case TPredefinedBasicTypeEnum_Unicode255:
	case TPredefinedBasicTypeEnum_Struct:
	case TPredefinedBasicTypeEnum_EntryTime:
	case TPredefinedBasicTypeEnum_Check:
	case TPredefinedBasicTypeEnum_ObjRef:
	case TPredefinedBasicTypeEnum_Currency:
	case TPredefinedBasicTypeEnum_PhyComAddr:
	case TPredefinedBasicTypeEnum_TrgOps:
	case TPredefinedBasicTypeEnum_OptFlds:
	case TPredefinedBasicTypeEnum_SvOptFlds:
	case TPredefinedBasicTypeEnum_LogOptFlds:
	case TPredefinedBasicTypeEnum_EntryID:
	case TPredefinedBasicTypeEnum_Octet6:
	case TPredefinedBasicTypeEnum_Octet16:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedBasicTypeEnum")
	}

	return nil
}

const (
	TPredefinedBasicTypeEnum_BOOLEAN      TPredefinedBasicTypeEnum = "BOOLEAN"
	TPredefinedBasicTypeEnum_INT8         TPredefinedBasicTypeEnum = "INT8"
	TPredefinedBasicTypeEnum_INT16        TPredefinedBasicTypeEnum = "INT16"
	TPredefinedBasicTypeEnum_INT24        TPredefinedBasicTypeEnum = "INT24"
	TPredefinedBasicTypeEnum_INT32        TPredefinedBasicTypeEnum = "INT32"
	TPredefinedBasicTypeEnum_INT64        TPredefinedBasicTypeEnum = "INT64"
	TPredefinedBasicTypeEnum_INT128       TPredefinedBasicTypeEnum = "INT128"
	TPredefinedBasicTypeEnum_INT8U        TPredefinedBasicTypeEnum = "INT8U"
	TPredefinedBasicTypeEnum_INT16U       TPredefinedBasicTypeEnum = "INT16U"
	TPredefinedBasicTypeEnum_INT24U       TPredefinedBasicTypeEnum = "INT24U"
	TPredefinedBasicTypeEnum_INT32U       TPredefinedBasicTypeEnum = "INT32U"
	TPredefinedBasicTypeEnum_FLOAT32      TPredefinedBasicTypeEnum = "FLOAT32"
	TPredefinedBasicTypeEnum_FLOAT64      TPredefinedBasicTypeEnum = "FLOAT64"
	TPredefinedBasicTypeEnum_Enum         TPredefinedBasicTypeEnum = "Enum"
	TPredefinedBasicTypeEnum_Dbpos        TPredefinedBasicTypeEnum = "Dbpos"
	TPredefinedBasicTypeEnum_Tcmd         TPredefinedBasicTypeEnum = "Tcmd"
	TPredefinedBasicTypeEnum_Quality      TPredefinedBasicTypeEnum = "Quality"
	TPredefinedBasicTypeEnum_Timestamp    TPredefinedBasicTypeEnum = "Timestamp"
	TPredefinedBasicTypeEnum_VisString32  TPredefinedBasicTypeEnum = "VisString32"
	TPredefinedBasicTypeEnum_VisString64  TPredefinedBasicTypeEnum = "VisString64"
	TPredefinedBasicTypeEnum_VisString65  TPredefinedBasicTypeEnum = "VisString65"
	TPredefinedBasicTypeEnum_VisString129 TPredefinedBasicTypeEnum = "VisString129"
	TPredefinedBasicTypeEnum_VisString255 TPredefinedBasicTypeEnum = "VisString255"
	TPredefinedBasicTypeEnum_Octet64      TPredefinedBasicTypeEnum = "Octet64"
	TPredefinedBasicTypeEnum_Unicode255   TPredefinedBasicTypeEnum = "Unicode255"
	TPredefinedBasicTypeEnum_Struct       TPredefinedBasicTypeEnum = "Struct"
	TPredefinedBasicTypeEnum_EntryTime    TPredefinedBasicTypeEnum = "EntryTime"
	TPredefinedBasicTypeEnum_Check        TPredefinedBasicTypeEnum = "Check"
	TPredefinedBasicTypeEnum_ObjRef       TPredefinedBasicTypeEnum = "ObjRef"
	TPredefinedBasicTypeEnum_Currency     TPredefinedBasicTypeEnum = "Currency"
	TPredefinedBasicTypeEnum_PhyComAddr   TPredefinedBasicTypeEnum = "PhyComAddr"
	TPredefinedBasicTypeEnum_TrgOps       TPredefinedBasicTypeEnum = "TrgOps"
	TPredefinedBasicTypeEnum_OptFlds      TPredefinedBasicTypeEnum = "OptFlds"
	TPredefinedBasicTypeEnum_SvOptFlds    TPredefinedBasicTypeEnum = "SvOptFlds"
	TPredefinedBasicTypeEnum_LogOptFlds   TPredefinedBasicTypeEnum = "LogOptFlds"
	TPredefinedBasicTypeEnum_EntryID      TPredefinedBasicTypeEnum = "EntryID"
	TPredefinedBasicTypeEnum_Octet6       TPredefinedBasicTypeEnum = "Octet6"
	TPredefinedBasicTypeEnum_Octet16      TPredefinedBasicTypeEnum = "Octet16"
)

// "SimpleType"
// base:"tPredefinedBasicTypeEnum"
// TBasicTypeEnum ...
type TBasicTypeEnum string

func (t *TBasicTypeEnum) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TValKindEnum ...
type TValKindEnum string

func (t *TValKindEnum) Validate() error {
	// check all enums
	switch *t {
	case TValKindEnum_Spec:
	case TValKindEnum_Conf:
	case TValKindEnum_RO:
	case TValKindEnum_Set:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TValKindEnum")
	}

	return nil
}

const (
	TValKindEnum_Spec TValKindEnum = "Spec"
	TValKindEnum_Conf TValKindEnum = "Conf"
	TValKindEnum_RO   TValKindEnum = "RO"
	TValKindEnum_Set  TValKindEnum = "Set"
)

// "SimpleType"
// base:"xs:Name"
// TGSEControlTypeEnum ...
type TGSEControlTypeEnum string

func (t *TGSEControlTypeEnum) Validate() error {
	// check all enums
	switch *t {
	case TGSEControlTypeEnum_GSSE:
	case TGSEControlTypeEnum_GOOSE:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TGSEControlTypeEnum")
	}

	return nil
}

const (
	TGSEControlTypeEnum_GSSE  TGSEControlTypeEnum = "GSSE"
	TGSEControlTypeEnum_GOOSE TGSEControlTypeEnum = "GOOSE"
)

// "SimpleType"
// base:"xs:normalizedString"
// TUnitMultiplierEnum ...
type TUnitMultiplierEnum string

func (t *TUnitMultiplierEnum) Validate() error {
	// check all enums
	switch *t {
	case TUnitMultiplierEnum_:
	case TUnitMultiplierEnum_m:
	case TUnitMultiplierEnum_k:
	case TUnitMultiplierEnum_M:
	case TUnitMultiplierEnum_mu:
	case TUnitMultiplierEnum_y:
	case TUnitMultiplierEnum_z:
	case TUnitMultiplierEnum_a:
	case TUnitMultiplierEnum_f:
	case TUnitMultiplierEnum_p:
	case TUnitMultiplierEnum_n:
	case TUnitMultiplierEnum_c:
	case TUnitMultiplierEnum_d:
	case TUnitMultiplierEnum_da:
	case TUnitMultiplierEnum_h:
	case TUnitMultiplierEnum_G:
	case TUnitMultiplierEnum_T:
	case TUnitMultiplierEnum_P:
	case TUnitMultiplierEnum_E:
	case TUnitMultiplierEnum_Z:
	case TUnitMultiplierEnum_Y:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TUnitMultiplierEnum")
	}

	return nil
}

const (
	TUnitMultiplierEnum_   TUnitMultiplierEnum = ""
	TUnitMultiplierEnum_m  TUnitMultiplierEnum = "m"
	TUnitMultiplierEnum_k  TUnitMultiplierEnum = "k"
	TUnitMultiplierEnum_M  TUnitMultiplierEnum = "M"
	TUnitMultiplierEnum_mu TUnitMultiplierEnum = "mu"
	TUnitMultiplierEnum_y  TUnitMultiplierEnum = "y"
	TUnitMultiplierEnum_z  TUnitMultiplierEnum = "z"
	TUnitMultiplierEnum_a  TUnitMultiplierEnum = "a"
	TUnitMultiplierEnum_f  TUnitMultiplierEnum = "f"
	TUnitMultiplierEnum_p  TUnitMultiplierEnum = "p"
	TUnitMultiplierEnum_n  TUnitMultiplierEnum = "n"
	TUnitMultiplierEnum_c  TUnitMultiplierEnum = "c"
	TUnitMultiplierEnum_d  TUnitMultiplierEnum = "d"
	TUnitMultiplierEnum_da TUnitMultiplierEnum = "da"
	TUnitMultiplierEnum_h  TUnitMultiplierEnum = "h"
	TUnitMultiplierEnum_G  TUnitMultiplierEnum = "G"
	TUnitMultiplierEnum_T  TUnitMultiplierEnum = "T"
	TUnitMultiplierEnum_P  TUnitMultiplierEnum = "P"
	TUnitMultiplierEnum_E  TUnitMultiplierEnum = "E"
	TUnitMultiplierEnum_Z  TUnitMultiplierEnum = "Z"
	TUnitMultiplierEnum_Y  TUnitMultiplierEnum = "Y"
)

// "SimpleType"
// base:"xs:normalizedString"
// TRightEnum ...
type TRightEnum string

func (t *TRightEnum) Validate() error {
	// check all enums
	switch *t {
	case TRightEnum_full:
	case TRightEnum_fix:
	case TRightEnum_dataflow:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TRightEnum")
	}

	return nil
}

const (
	TRightEnum_full     TRightEnum = "full"
	TRightEnum_fix      TRightEnum = "fix"
	TRightEnum_dataflow TRightEnum = "dataflow"
)

// "SimpleType"
// TSDOCount ...
type TSDOCount struct { /* UNION */
	Content        string `xml:",chardata" json:",omitempty"`
	unsignedInt    *UnsignedInt
	tRestrName1stL *TRestrName1stL
}

func (t *TSDOCount) IsEmpty() bool { return t.Content == "" }
func (t *TSDOCount) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TSDOCount) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TSDOCount) Validate() error {
	{
		p := UnsignedInt(t.Content)
		t.unsignedInt = &p
		if err := t.unsignedInt.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.unsignedInt = nil
		}
	}
	{
		p := TRestrName1stL(t.Content)
		t.tRestrName1stL = &p
		if err := t.tRestrName1stL.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tRestrName1stL = nil
		}
	}
	return errors.New("не нашли member from union TSDOCount")
UnionLabel:

	return nil
}

// "SimpleType"
// TDACount ...
type TDACount struct { /* UNION */
	Content            string `xml:",chardata" json:",omitempty"`
	unsignedInt        *UnsignedInt
	tAttributeNameEnum *TAttributeNameEnum
}

func (t *TDACount) IsEmpty() bool { return t.Content == "" }
func (t *TDACount) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TDACount) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TDACount) Validate() error {
	{
		p := UnsignedInt(t.Content)
		t.unsignedInt = &p
		if err := t.unsignedInt.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.unsignedInt = nil
		}
	}
	{
		p := TAttributeNameEnum{Content: t.Content}
		t.tAttributeNameEnum = &p
		if err := t.tAttributeNameEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tAttributeNameEnum = nil
		}
	}
	return errors.New("не нашли member from union TDACount")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TSmpMod ...
type TSmpMod string

func (t *TSmpMod) Validate() error {
	// check all enums
	switch *t {
	case TSmpMod_SmpPerPeriod:
	case TSmpMod_SmpPerSec:
	case TSmpMod_SecPerSmp:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TSmpMod")
	}

	return nil
}

const (
	TSmpMod_SmpPerPeriod TSmpMod = "SmpPerPeriod"
	TSmpMod_SmpPerSec    TSmpMod = "SmpPerSec"
	TSmpMod_SecPerSmp    TSmpMod = "SecPerSmp"
)

// "SimpleType"
// base:"xs:normalizedString"
// TPredefinedPhysConnTypeEnum ...
type TPredefinedPhysConnTypeEnum string

func (t *TPredefinedPhysConnTypeEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedPhysConnTypeEnum_Connection:
	case TPredefinedPhysConnTypeEnum_RedConn:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedPhysConnTypeEnum")
	}

	return nil
}

const (
	TPredefinedPhysConnTypeEnum_Connection TPredefinedPhysConnTypeEnum = "Connection"
	TPredefinedPhysConnTypeEnum_RedConn    TPredefinedPhysConnTypeEnum = "RedConn"
)

// "SimpleType"
// base:"xs:normalizedString"
// TExtensionPhysConnTypeEnum ...
type TExtensionPhysConnTypeEnum string

func (t *TExtensionPhysConnTypeEnum) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[A-Z][0-9A-Za-z\-]*$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TExtensionPhysConnTypeEnum")
	}

	return nil
}

// "SimpleType"
// TPhysConnTypeEnum ...
type TPhysConnTypeEnum struct { /* UNION */
	Content                     string `xml:",chardata" json:",omitempty"`
	tExtensionPhysConnTypeEnum  *TExtensionPhysConnTypeEnum
	tPredefinedPhysConnTypeEnum *TPredefinedPhysConnTypeEnum
}

func (t *TPhysConnTypeEnum) IsEmpty() bool { return t.Content == "" }
func (t *TPhysConnTypeEnum) UnmarshalXMLAttr(attr xml.Attr) error {
	t.Content = attr.Value
	return nil
}
func (t *TPhysConnTypeEnum) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	return xml.Attr{
		Name:  name,
		Value: t.Content,
	}, nil
}

func (t *TPhysConnTypeEnum) Validate() error {
	{
		p := TPredefinedPhysConnTypeEnum(t.Content)
		t.tPredefinedPhysConnTypeEnum = &p
		if err := t.tPredefinedPhysConnTypeEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tPredefinedPhysConnTypeEnum = nil
		}
	}
	{
		p := TExtensionPhysConnTypeEnum(t.Content)
		t.tExtensionPhysConnTypeEnum = &p
		if err := t.tExtensionPhysConnTypeEnum.Validate(); err == nil {
			goto UnionLabel
		} else {
			t.tExtensionPhysConnTypeEnum = nil
		}
	}
	return errors.New("не нашли member from union TPhysConnTypeEnum")
UnionLabel:

	return nil
}

// "SimpleType"
// base:"xs:Name"
// TServiceType ...
type TServiceType string

func (t *TServiceType) Validate() error {
	// check all enums
	switch *t {
	case TServiceType_Poll:
	case TServiceType_Report:
	case TServiceType_GOOSE:
	case TServiceType_SMV:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TServiceType")
	}

	return nil
}

const (
	TServiceType_Poll   TServiceType = "Poll"
	TServiceType_Report TServiceType = "Report"
	TServiceType_GOOSE  TServiceType = "GOOSE"
	TServiceType_SMV    TServiceType = "SMV"
)

// "SimpleType"
// base:"xs:normalizedString"
// TPredefinedTypeOfSecurityEnum ...
type TPredefinedTypeOfSecurityEnum string

func (t *TPredefinedTypeOfSecurityEnum) Validate() error {
	// check all enums
	switch *t {
	case TPredefinedTypeOfSecurityEnum_None:
	case TPredefinedTypeOfSecurityEnum_Signature:
	case TPredefinedTypeOfSecurityEnum_SignatureAndEncryption:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TPredefinedTypeOfSecurityEnum")
	}

	return nil
}

const (
	TPredefinedTypeOfSecurityEnum_None                   TPredefinedTypeOfSecurityEnum = "None"
	TPredefinedTypeOfSecurityEnum_Signature              TPredefinedTypeOfSecurityEnum = "Signature"
	TPredefinedTypeOfSecurityEnum_SignatureAndEncryption TPredefinedTypeOfSecurityEnum = "SignatureAndEncryption"
)

/---------------------------------------------------/
Done. test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="OutputDir test/go/output/test/complex_xsd"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tIED"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServices"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tAccessPoint"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tCertificate"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tCert"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServerAt"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: Authentication"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServer"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLDevice"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tAccessControl"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tAssociation"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: LN0"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tAnyLN"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLN"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLN0"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tDataSet"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tFCDA"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tControl"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tControlWithTriggerOpt"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tTrgOps"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: OptFields"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tReportControl"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tRptEnabled"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tClientLN"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLogControl"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tInputs"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tExtRef"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLog"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: IEDName"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tControlWithIEDName"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tProtocol"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tGSEControl"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: SmvOpts"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSampledValueControl"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSettingControl"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tDOI"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSDI"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tDAI"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceYesNo"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceWithOptionalMax"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceWithMax"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceWithMaxNonZero"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceConfReportControl"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceWithMaxAndMaxAttributes"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceWithMaxAndModify"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceForConfDataSet"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tClientServices"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tServiceSettings"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tReportSettings"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLogSettings"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tGSESettings"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSMVSettings"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tConfLNs"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tValueHandling"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tFileHandling"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tGOOSEcapabilities"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tRedProt"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tTimeSyncProt"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSMVsc"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSupSubscription"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tCommProt"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tMcSecurity"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tKDC"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: SGEdit"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: ConfSG"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSettingGroups"
/---------------------------------------------------/
package schema

import (
	"errors"
	"fmt"
	"regexp"
)

// "AttributeGroup"
// AgAuthentication ...
type AgAuthentication struct {
	NoneAttr        *bool `xml:"none,attr,omitempty" json:"none,omitempty"`
	PasswordAttr    *bool `xml:"password,attr,omitempty" json:"password,omitempty"`
	WeakAttr        *bool `xml:"weak,attr,omitempty" json:"weak,omitempty"`
	StrongAttr      *bool `xml:"strong,attr,omitempty" json:"strong,omitempty"`
	CertificateAttr *bool `xml:"certificate,attr,omitempty" json:"certificate,omitempty"`
}

func (t *AgAuthentication) Validate() error {

	return nil
}

// "AttributeGroup"
// AgSmvOpts ...
type AgSmvOpts struct {
	RefreshTimeAttr        *bool `xml:"refreshTime,attr,omitempty" json:"refreshTime,omitempty"`
	SampleSynchronizedAttr *bool `xml:"sampleSynchronized,attr,omitempty" json:"sampleSynchronized,omitempty"`
	SampleRateAttr         *bool `xml:"sampleRate,attr,omitempty" json:"sampleRate,omitempty"`
	DataSetAttr            *bool `xml:"dataSet,attr,omitempty" json:"dataSet,omitempty"`
	SecurityAttr           *bool `xml:"security,attr,omitempty" json:"security,omitempty"`
	TimestampAttr          *bool `xml:"timestamp,attr,omitempty" json:"timestamp,omitempty"`
	SynchSourceIdAttr      *bool `xml:"synchSourceId,attr,omitempty" json:"synchSourceId,omitempty"`
}

func (t *AgSmvOpts) Validate() error {

	return nil
}

// "AttributeGroup"
// AgOptFields ...
type AgOptFields struct {
	SeqNumAttr     *bool `xml:"seqNum,attr,omitempty" json:"seqNum,omitempty"`
	TimeStampAttr  *bool `xml:"timeStamp,attr,omitempty" json:"timeStamp,omitempty"`
	DataSetAttr    *bool `xml:"dataSet,attr,omitempty" json:"dataSet,omitempty"`
	ReasonCodeAttr *bool `xml:"reasonCode,attr,omitempty" json:"reasonCode,omitempty"`
	DataRefAttr    *bool `xml:"dataRef,attr,omitempty" json:"dataRef,omitempty"`
	EntryIDAttr    *bool `xml:"entryID,attr,omitempty" json:"entryID,omitempty"`
	ConfigRefAttr  *bool `xml:"configRef,attr,omitempty" json:"configRef,omitempty"`
	BufOvflAttr    *bool `xml:"bufOvfl,attr,omitempty" json:"bufOvfl,omitempty"`
}

func (t *AgOptFields) Validate() error {

	return nil
}

// "AttributeGroup"
// AgLDRef ...
type AgLDRef struct {
	IedNameAttr TIEDName `xml:"iedName,attr" json:"iedName"`
	LdInstAttr  TLDInst  `xml:"ldInst,attr" json:"ldInst"`
}

func (t *AgLDRef) Validate() error {
	if err := t.IedNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.LdInstAttr.Validate(); err != nil {
		return err
	}

	return nil
}

// "AttributeGroup"
// AgLNRef ...
type AgLNRef struct {
	PrefixAttr  *TPrefix       `xml:"prefix,attr,omitempty" json:"prefix,omitempty"`
	LnClassAttr TLNClassEnum   `xml:"lnClass,attr" json:"lnClass"`
	LnInstAttr  TLNInstOrEmpty `xml:"lnInst,attr" json:"lnInst"`
}

func (t *AgLNRef) Validate() error {
	if err := t.PrefixAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnInstAttr.Validate(); err != nil {
		return err
	}

	return nil
}

// "ComplexType"
// TIED ...
type TIED struct {
	TUnNaming
	NameAttr                TIEDName       `xml:"name,attr" json:"name"`
	TypeAttr                *string        `xml:"type,attr,omitempty" json:"type,omitempty"`
	ManufacturerAttr        *string        `xml:"manufacturer,attr,omitempty" json:"manufacturer,omitempty"`
	ConfigVersionAttr       *string        `xml:"configVersion,attr,omitempty" json:"configVersion,omitempty"`
	OriginalSclVersionAttr  *TSclVersion   `xml:"originalSclVersion,attr,omitempty" json:"originalSclVersion,omitempty"`
	OriginalSclRevisionAttr *TSclRevision  `xml:"originalSclRevision,attr,omitempty" json:"originalSclRevision,omitempty"`
	OriginalSclReleaseAttr  *TSclRelease   `xml:"originalSclRelease,attr,omitempty" json:"originalSclRelease,omitempty"`
	EngRightAttr            *TRightEnum    `xml:"engRight,attr,omitempty" json:"engRight,omitempty"`
	OwnerAttr               *string        `xml:"owner,attr,omitempty" json:"owner,omitempty"`
	Services                *TServices     `xml:"Services" json:"Services"`
	AccessPoint             []TAccessPoint `xml:"AccessPoint" json:"AccessPoint"`
	KDC                     []TKDC         `xml:"KDC" json:"KDC"`
}

func (t *TIED) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tIEDName"
	if t.NameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "name", "TIED")
	}
	if err := t.OriginalSclVersionAttr.Validate(); err != nil {
		return err
	}
	if err := t.OriginalSclRevisionAttr.Validate(); err != nil {
		return err
	}
	if err := t.OriginalSclReleaseAttr.Validate(); err != nil {
		return err
	}
	if err := t.EngRightAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.Services); err != nil {
		return err
	}
	for _, el := range t.AccessPoint {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.KDC {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:token"
// TServicesNameLengthToken ...
type TServicesNameLengthToken string

func (t *TServicesNameLengthToken) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^32$`, `^64$`, `^6[5-9]$`, `^[7-9]\d$`, `^[1-9]\d\d+$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TServicesNameLengthToken")
	}

	return nil
}

// "ComplexType"
// TServices ...
type TServices struct {
	NodeID
	NameLengthAttr          *TServicesNameLengthToken        `xml:"nameLength,attr,omitempty" json:"nameLength,omitempty"`
	DynAssociation          *TServiceWithOptionalMax         `xml:"DynAssociation" json:"DynAssociation"`
	SettingGroups           *TSettingGroups                  `xml:"SettingGroups" json:"SettingGroups"`
	GetDirectory            *TServiceYesNo                   `xml:"GetDirectory" json:"GetDirectory"`
	GetDataObjectDefinition *TServiceYesNo                   `xml:"GetDataObjectDefinition" json:"GetDataObjectDefinition"`
	DataObjectDirectory     *TServiceYesNo                   `xml:"DataObjectDirectory" json:"DataObjectDirectory"`
	GetDataSetValue         *TServiceYesNo                   `xml:"GetDataSetValue" json:"GetDataSetValue"`
	SetDataSetValue         *TServiceYesNo                   `xml:"SetDataSetValue" json:"SetDataSetValue"`
	DataSetDirectory        *TServiceYesNo                   `xml:"DataSetDirectory" json:"DataSetDirectory"`
	ConfDataSet             *TServiceForConfDataSet          `xml:"ConfDataSet" json:"ConfDataSet"`
	DynDataSet              *TServiceWithMaxAndMaxAttributes `xml:"DynDataSet" json:"DynDataSet"`
	ReadWrite               *TServiceYesNo                   `xml:"ReadWrite" json:"ReadWrite"`
	TimerActivatedControl   *TServiceYesNo                   `xml:"TimerActivatedControl" json:"TimerActivatedControl"`
	ConfReportControl       *TServiceConfReportControl       `xml:"ConfReportControl" json:"ConfReportControl"`
	GetCBValues             *TServiceYesNo                   `xml:"GetCBValues" json:"GetCBValues"`
	ConfLogControl          *TServiceWithMaxNonZero          `xml:"ConfLogControl" json:"ConfLogControl"`
	ReportSettings          *TReportSettings                 `xml:"ReportSettings" json:"ReportSettings"`
	LogSettings             *TLogSettings                    `xml:"LogSettings" json:"LogSettings"`
	GSESettings             *TGSESettings                    `xml:"GSESettings" json:"GSESettings"`
	SMVSettings             *TSMVSettings                    `xml:"SMVSettings" json:"SMVSettings"`
	GSEDir                  *TServiceYesNo                   `xml:"GSEDir" json:"GSEDir"`
	GOOSE                   *TGOOSEcapabilities              `xml:"GOOSE" json:"GOOSE"`
	GSSE                    *TServiceWithMax                 `xml:"GSSE" json:"GSSE"`
	SMVsc                   *TSMVsc                          `xml:"SMVsc" json:"SMVsc"`
	FileHandling            *TFileHandling                   `xml:"FileHandling" json:"FileHandling"`
	ConfLNs                 *TConfLNs                        `xml:"ConfLNs" json:"ConfLNs"`
	ClientServices          *TClientServices                 `xml:"ClientServices" json:"ClientServices"`
	ConfLdName              *TServiceYesNo                   `xml:"ConfLdName" json:"ConfLdName"`
	SupSubscription         *TSupSubscription                `xml:"SupSubscription" json:"SupSubscription"`
	ConfSigRef              *TServiceWithMaxNonZero          `xml:"ConfSigRef" json:"ConfSigRef"`
	ValueHandling           *TValueHandling                  `xml:"ValueHandling" json:"ValueHandling"`
	RedProt                 *TRedProt                        `xml:"RedProt" json:"RedProt"`
	TimeSyncProt            *TTimeSyncProt                   `xml:"TimeSyncProt" json:"TimeSyncProt"`
	CommProt                *TCommProt                       `xml:"CommProt" json:"CommProt"`
}

func (t *TServices) Validate() error {
	// AttributeGroup

	// Attributes
	if err := t.NameLengthAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.DynAssociation); err != nil {
		return err
	}
	if err := CheckValidate(t.SettingGroups); err != nil {
		return err
	}
	if err := CheckValidate(t.GetDirectory); err != nil {
		return err
	}
	if err := CheckValidate(t.GetDataObjectDefinition); err != nil {
		return err
	}
	if err := CheckValidate(t.DataObjectDirectory); err != nil {
		return err
	}
	if err := CheckValidate(t.GetDataSetValue); err != nil {
		return err
	}
	if err := CheckValidate(t.SetDataSetValue); err != nil {
		return err
	}
	if err := CheckValidate(t.DataSetDirectory); err != nil {
		return err
	}
	if err := CheckValidate(t.ConfDataSet); err != nil {
		return err
	}
	if err := CheckValidate(t.DynDataSet); err != nil {
		return err
	}
	if err := CheckValidate(t.ReadWrite); err != nil {
		return err
	}
	if err := CheckValidate(t.TimerActivatedControl); err != nil {
		return err
	}
	if err := CheckValidate(t.ConfReportControl); err != nil {
		return err
	}
	if err := CheckValidate(t.GetCBValues); err != nil {
		return err
	}
	if err := CheckValidate(t.ConfLogControl); err != nil {
		return err
	}
	if err := CheckValidate(t.ReportSettings); err != nil {
		return err
	}
	if err := CheckValidate(t.LogSettings); err != nil {
		return err
	}
	if err := CheckValidate(t.GSESettings); err != nil {
		return err
	}
	if err := CheckValidate(t.SMVSettings); err != nil {
		return err
	}
	if err := CheckValidate(t.GSEDir); err != nil {
		return err
	}
	if err := CheckValidate(t.GOOSE); err != nil {
		return err
	}
	if err := CheckValidate(t.GSSE); err != nil {
		return err
	}
	if err := CheckValidate(t.SMVsc); err != nil {
		return err
	}
	if err := CheckValidate(t.FileHandling); err != nil {
		return err
	}
	if err := CheckValidate(t.ConfLNs); err != nil {
		return err
	}
	if err := CheckValidate(t.ClientServices); err != nil {
		return err
	}
	if err := CheckValidate(t.ConfLdName); err != nil {
		return err
	}
	if err := CheckValidate(t.SupSubscription); err != nil {
		return err
	}
	if err := CheckValidate(t.ConfSigRef); err != nil {
		return err
	}
	if err := CheckValidate(t.ValueHandling); err != nil {
		return err
	}
	if err := CheckValidate(t.RedProt); err != nil {
		return err
	}
	if err := CheckValidate(t.TimeSyncProt); err != nil {
		return err
	}
	if err := CheckValidate(t.CommProt); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TAccessPoint ...
type TAccessPoint struct {
	TUnNaming
	NameAttr      TAccessPointName `xml:"name,attr" json:"name"`
	RouterAttr    *bool            `xml:"router,attr,omitempty" json:"router,omitempty"`
	ClockAttr     *bool            `xml:"clock,attr,omitempty" json:"clock,omitempty"`
	KdcAttr       *bool            `xml:"kdc,attr,omitempty" json:"kdc,omitempty"`
	Server        *TServer         `xml:"Server" json:"Server"`
	SclLN         []TLN            `xml:"scl:LN" json:"scl:LN"`
	ServerAt      *TServerAt       `xml:"ServerAt" json:"ServerAt"`
	Services      *TServices       `xml:"Services" json:"Services"`
	GOOSESecurity []TCertificate   `xml:"GOOSESecurity" json:"GOOSESecurity"`
	SMVSecurity   []TCertificate   `xml:"SMVSecurity" json:"SMVSecurity"`
}

func (t *TAccessPoint) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tAccessPointName"
	if t.NameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "name", "TAccessPoint")
	}
	// Elements
	if err := CheckValidate(t.Server); err != nil {
		return err
	}
	for _, el := range t.SclLN {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	if err := CheckValidate(t.ServerAt); err != nil {
		return err
	}
	if err := CheckValidate(t.Services); err != nil {
		return err
	}
	for _, el := range t.GOOSESecurity {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.SMVSecurity {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TCertificateSerialNumberNormalizedString ...
type TCertificateSerialNumberNormalizedString string

func (t *TCertificateSerialNumberNormalizedString) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^[0-9]+$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TCertificateSerialNumberNormalizedString")
	}
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TCertificateSerialNumberNormalizedString")
	}

	return nil
}

// "ComplexType"
// TCertificate ...
type TCertificate struct {
	TNaming
	XferNumberAttr   *uint32                                  `xml:"xferNumber,attr,omitempty" json:"xferNumber,omitempty"`
	SerialNumberAttr TCertificateSerialNumberNormalizedString `xml:"serialNumber,attr" json:"serialNumber"`
	Subject          TCert                                    `xml:"Subject" json:"Subject"`
	IssuerName       TCert                                    `xml:"IssuerName" json:"IssuerName"`
}

func (t *TCertificate) Validate() error {
	if err := t.TNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.SerialNumberAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type=""
	if t.SerialNumberAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "serialNumber", "TCertificate")
	}
	// Elements
	if err := CheckValidate(t.Subject); err != nil {
		return err
	}
	if err := CheckValidate(t.IssuerName); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TCertCommonNameNormalizedString ...
type TCertCommonNameNormalizedString string

func (t *TCertCommonNameNormalizedString) Validate() error {
	var checkPattern bool
	for _, p := range []string{`^none$`, `^CN=.+$`} {
		if ok, err := regexp.MatchString(p, string(*t)); err != nil {
			return err
		} else {
			if ok {
				checkPattern = true
				break
			}
		}
	}
	if checkPattern == false {
		return errors.New("none were found match pattern: " + "TCertCommonNameNormalizedString")
	}
	if len(*t) < 4 {
		return errors.New("меньше минимального 4 значение в TCertCommonNameNormalizedString")
	}

	return nil
}

// "SimpleType"
// base:"xs:normalizedString"
// TCertIdHierarchyNormalizedString ...
type TCertIdHierarchyNormalizedString string

func (t *TCertIdHierarchyNormalizedString) Validate() error {
	if len(*t) < 1 {
		return errors.New("меньше минимального 1 значение в TCertIdHierarchyNormalizedString")
	}

	return nil
}

// "ComplexType"
// TCert ...
type TCert struct {
	NodeID
	CommonNameAttr  TCertCommonNameNormalizedString  `xml:"commonName,attr" json:"commonName"`
	IdHierarchyAttr TCertIdHierarchyNormalizedString `xml:"idHierarchy,attr" json:"idHierarchy"`
}

func (t *TCert) Validate() error {
	// AttributeGroup

	// Attributes
	if err := t.CommonNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type=""
	if t.CommonNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "commonName", "TCert")
	}
	if err := t.IdHierarchyAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type=""
	if t.IdHierarchyAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "idHierarchy", "TCert")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TServerAt ...
type TServerAt struct {
	TUnNaming
	ApNameAttr TAccessPointName `xml:"apName,attr" json:"apName"`
}

func (t *TServerAt) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.ApNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tAccessPointName"
	if t.ApNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "apName", "TServerAt")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// Authentication ...
type Authentication struct {
	NodeID
	AgAuthentication // AttributeGroup
}

func (t *Authentication) Validate() error {
	// AttributeGroup
	if err := t.AgAuthentication.Validate(); err != nil {
		return err
	}

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TServer ...
type TServer struct {
	TUnNaming
	TimeoutAttr    *uint32        `xml:"timeout,attr,omitempty" json:"timeout,omitempty"`
	Authentication Authentication `xml:"Authentication" json:"Authentication"`
	LDevice        []TLDevice     `xml:"LDevice" json:"LDevice"`
	Association    []TAssociation `xml:"Association" json:"Association"`
}

func (t *TServer) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	if err := CheckValidate(t.Authentication); err != nil {
		return err
	}
	for _, el := range t.LDevice {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Association {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TLDevice ...
type TLDevice struct {
	TUnNaming
	InstAttr      TLDInst         `xml:"inst,attr" json:"inst"`
	LdNameAttr    *TLDName        `xml:"ldName,attr,omitempty" json:"ldName,omitempty"`
	LN0           LN0             `xml:"LN0" json:"LN0"`
	LN            []TLN           `xml:"LN" json:"LN"`
	AccessControl *TAccessControl `xml:"AccessControl" json:"AccessControl"`
}

func (t *TLDevice) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.InstAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tLDInst"
	if t.InstAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "inst", "TLDevice")
	}
	if err := t.LdNameAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.LN0); err != nil {
		return err
	}
	for _, el := range t.LN {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	if err := CheckValidate(t.AccessControl); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TAccessControl ...
type TAccessControl struct {
	TAnyContentFromOtherNamespace
}

func (t *TAccessControl) Validate() error {
	if err := t.TAnyContentFromOtherNamespace.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TAssociation ...
type TAssociation struct {
	NodeID
	AgLNRef                                // AttributeGroup
	KindAttr          TAssociationKindEnum `xml:"kind,attr" json:"kind"`
	AssociationIDAttr *TAssociationID      `xml:"associationID,attr,omitempty" json:"associationID,omitempty"`
}

func (t *TAssociation) Validate() error {
	// AttributeGroup
	if err := t.AgLNRef.Validate(); err != nil {
		return err
	}

	// Attributes
	if err := t.KindAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tAssociationKindEnum"
	if t.KindAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "kind", "TAssociation")
	}
	if err := t.AssociationIDAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// LN0 ...
type LN0 struct {
	TLN0
}

func (t *LN0) Validate() error {
	if err := t.TLN0.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "Element"// "Element"
// LN ...
type LN = TLN

// "ComplexType"
// TAnyLN ...
type TAnyLN struct {
	TUnNaming
	LnTypeAttr    TName            `xml:"lnType,attr" json:"lnType"`
	DataSet       []TDataSet       `xml:"DataSet" json:"DataSet"`
	ReportControl []TReportControl `xml:"ReportControl" json:"ReportControl"`
	LogControl    []TLogControl    `xml:"LogControl" json:"LogControl"`
	DOI           []TDOI           `xml:"DOI" json:"DOI"`
	Inputs        *TInputs         `xml:"Inputs" json:"Inputs"`
	Log           []TLog           `xml:"Log" json:"Log"`
}

func (t *TAnyLN) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.LnTypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tName"
	if t.LnTypeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "lnType", "TAnyLN")
	}
	// Elements
	for _, el := range t.DataSet {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.ReportControl {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.LogControl {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.DOI {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	if err := CheckValidate(t.Inputs); err != nil {
		return err
	}
	for _, el := range t.Log {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TLN ...
type TLN struct {
	TAnyLN
	PrefixAttr  *TPrefix     `xml:"prefix,attr,omitempty" json:"prefix,omitempty"`
	LnClassAttr TLNClassEnum `xml:"lnClass,attr" json:"lnClass"`
	InstAttr    TLNInst      `xml:"inst,attr" json:"inst"`
}

func (t *TLN) Validate() error {
	if err := t.TAnyLN.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.PrefixAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tLNClassEnum"
	if t.LnClassAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "lnClass", "TLN")
	}
	if err := t.InstAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tLNInst"
	if t.InstAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "inst", "TLN")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TLN0 ...
type TLN0 struct {
	TAnyLN
	LnClassAttr         TLNClassEnum           `xml:"lnClass,attr" json:"lnClass"`
	InstAttr            string                 `xml:"inst,attr" json:"inst"`
	GSEControl          []TGSEControl          `xml:"GSEControl" json:"GSEControl"`
	SampledValueControl []TSampledValueControl `xml:"SampledValueControl" json:"SampledValueControl"`
	SettingControl      *TSettingControl       `xml:"SettingControl" json:"SettingControl"`
}

func (t *TLN0) Validate() error {
	if err := t.TAnyLN.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tLNClassEnum"
	if t.LnClassAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "lnClass", "TLN0")
	}
	// check use='required'  type="string"
	if t.InstAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "inst", "TLN0")
	}
	// Elements
	for _, el := range t.GSEControl {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.SampledValueControl {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	if err := CheckValidate(t.SettingControl); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDataSet ...
type TDataSet struct {
	TUnNaming
	NameAttr TDataSetName `xml:"name,attr" json:"name"`
	FCDA     []TFCDA      `xml:"FCDA" json:"FCDA"`
}

func (t *TDataSet) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tDataSetName"
	if t.NameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "name", "TDataSet")
	}
	// Elements
	for _, el := range t.FCDA {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TFCDA ...
type TFCDA struct {
	NodeID
	LdInstAttr  *TLDInst            `xml:"ldInst,attr,omitempty" json:"ldInst,omitempty"`
	PrefixAttr  *TPrefix            `xml:"prefix,attr,omitempty" json:"prefix,omitempty"`
	LnClassAttr *TLNClassEnum       `xml:"lnClass,attr,omitempty" json:"lnClass,omitempty"`
	LnInstAttr  *TLNInst            `xml:"lnInst,attr,omitempty" json:"lnInst,omitempty"`
	DoNameAttr  *TFullDOName        `xml:"doName,attr,omitempty" json:"doName,omitempty"`
	DaNameAttr  *TFullAttributeName `xml:"daName,attr,omitempty" json:"daName,omitempty"`
	FcAttr      TFCEnum             `xml:"fc,attr" json:"fc"`
	IxAttr      *uint32             `xml:"ix,attr,omitempty" json:"ix,omitempty"`
}

func (t *TFCDA) Validate() error {
	// AttributeGroup

	// Attributes
	if err := t.LdInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.PrefixAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.DoNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.DaNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.FcAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tFCEnum"
	if t.FcAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "fc", "TFCDA")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TControl ...
type TControl struct {
	TUnNaming
	NameAttr   TCBName       `xml:"name,attr" json:"name"`
	DatSetAttr *TDataSetName `xml:"datSet,attr,omitempty" json:"datSet,omitempty"`
}

func (t *TControl) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tCBName"
	if t.NameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "name", "TControl")
	}
	if err := t.DatSetAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TControlWithTriggerOpt ...
type TControlWithTriggerOpt struct {
	TControl
	IntgPdAttr *uint32  `xml:"intgPd,attr,omitempty" json:"intgPd,omitempty"`
	TrgOps     *TTrgOps `xml:"TrgOps" json:"TrgOps"`
}

func (t *TControlWithTriggerOpt) Validate() error {
	if err := t.TControl.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	if err := CheckValidate(t.TrgOps); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TTrgOps ...
type TTrgOps struct {
	NodeID
	DchgAttr   *bool `xml:"dchg,attr,omitempty" json:"dchg,omitempty"`
	QchgAttr   *bool `xml:"qchg,attr,omitempty" json:"qchg,omitempty"`
	DupdAttr   *bool `xml:"dupd,attr,omitempty" json:"dupd,omitempty"`
	PeriodAttr *bool `xml:"period,attr,omitempty" json:"period,omitempty"`
	GiAttr     *bool `xml:"gi,attr,omitempty" json:"gi,omitempty"`
}

func (t *TTrgOps) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// OptFields ...
type OptFields struct {
	NodeID
	AgOptFields // AttributeGroup
}

func (t *OptFields) Validate() error {
	// AttributeGroup
	if err := t.AgOptFields.Validate(); err != nil {
		return err
	}

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TReportControl ...
type TReportControl struct {
	TControlWithTriggerOpt
	RptIDAttr    *TMessageID  `xml:"rptID,attr,omitempty" json:"rptID,omitempty"`
	ConfRevAttr  uint32       `xml:"confRev,attr" json:"confRev"`
	BufferedAttr *bool        `xml:"buffered,attr,omitempty" json:"buffered,omitempty"`
	BufTimeAttr  *uint32      `xml:"bufTime,attr,omitempty" json:"bufTime,omitempty"`
	IndexedAttr  *bool        `xml:"indexed,attr,omitempty" json:"indexed,omitempty"`
	OptFields    OptFields    `xml:"OptFields" json:"OptFields"`
	RptEnabled   *TRptEnabled `xml:"RptEnabled" json:"RptEnabled"`
}

func (t *TReportControl) Validate() error {
	if err := t.TControlWithTriggerOpt.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.RptIDAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="uint32"
	if t.ConfRevAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "confRev", "TReportControl")
	}
	// Elements
	if err := CheckValidate(t.OptFields); err != nil {
		return err
	}
	if err := CheckValidate(t.RptEnabled); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TRptEnabledMaxUnsignedInt ...
type TRptEnabledMaxUnsignedInt uint32

func (t *TRptEnabledMaxUnsignedInt) Validate() error {

	return nil
}

// "ComplexType"
// TRptEnabled ...
type TRptEnabled struct {
	TUnNaming
	MaxAttr  *TRptEnabledMaxUnsignedInt `xml:"max,attr,omitempty" json:"max,omitempty"`
	ClientLN []TClientLN                `xml:"ClientLN" json:"ClientLN"`
}

func (t *TRptEnabled) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.MaxAttr.Validate(); err != nil {
		return err
	}
	// Elements
	for _, el := range t.ClientLN {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TClientLN ...
type TClientLN struct {
	NodeID
	AgLNRef                     // AttributeGroup
	ApRefAttr *TAccessPointName `xml:"apRef,attr,omitempty" json:"apRef,omitempty"`
}

func (t *TClientLN) Validate() error {
	// AttributeGroup
	if err := t.AgLNRef.Validate(); err != nil {
		return err
	}

	// Attributes
	if err := t.ApRefAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TLogControl ...
type TLogControl struct {
	TControlWithTriggerOpt
	LdInstAttr     *TLDInst      `xml:"ldInst,attr,omitempty" json:"ldInst,omitempty"`
	PrefixAttr     *TPrefix      `xml:"prefix,attr,omitempty" json:"prefix,omitempty"`
	LnClassAttr    *TLNClassEnum `xml:"lnClass,attr,omitempty" json:"lnClass,omitempty"`
	LnInstAttr     *TLNInst      `xml:"lnInst,attr,omitempty" json:"lnInst,omitempty"`
	LogNameAttr    TLogName      `xml:"logName,attr" json:"logName"`
	LogEnaAttr     *bool         `xml:"logEna,attr,omitempty" json:"logEna,omitempty"`
	ReasonCodeAttr *bool         `xml:"reasonCode,attr,omitempty" json:"reasonCode,omitempty"`
	BufTimeAttr    *uint32       `xml:"bufTime,attr,omitempty" json:"bufTime,omitempty"`
}

func (t *TLogControl) Validate() error {
	if err := t.TControlWithTriggerOpt.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.LdInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.PrefixAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.LogNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tLogName"
	if t.LogNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "logName", "TLogControl")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TInputs ...
type TInputs struct {
	TUnNaming
	ExtRef []TExtRef `xml:"ExtRef" json:"ExtRef"`
}

func (t *TInputs) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.ExtRef {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TExtRef ...
type TExtRef struct {
	NodeID
	AgDesc                              // AttributeGroup
	IedNameAttr     *TIEDNameOrRelative `xml:"iedName,attr,omitempty" json:"iedName,omitempty"`
	LdInstAttr      *TLDInst            `xml:"ldInst,attr,omitempty" json:"ldInst,omitempty"`
	PrefixAttr      *TPrefix            `xml:"prefix,attr,omitempty" json:"prefix,omitempty"`
	LnClassAttr     *TLNClassEnum       `xml:"lnClass,attr,omitempty" json:"lnClass,omitempty"`
	LnInstAttr      *TLNInst            `xml:"lnInst,attr,omitempty" json:"lnInst,omitempty"`
	DoNameAttr      *TFullDOName        `xml:"doName,attr,omitempty" json:"doName,omitempty"`
	DaNameAttr      *TFullAttributeName `xml:"daName,attr,omitempty" json:"daName,omitempty"`
	IntAddrAttr     *string             `xml:"intAddr,attr,omitempty" json:"intAddr,omitempty"`
	ServiceTypeAttr *TServiceType       `xml:"serviceType,attr,omitempty" json:"serviceType,omitempty"`
	SrcLDInstAttr   *TLDInst            `xml:"srcLDInst,attr,omitempty" json:"srcLDInst,omitempty"`
	SrcPrefixAttr   *TPrefix            `xml:"srcPrefix,attr,omitempty" json:"srcPrefix,omitempty"`
	SrcLNClassAttr  *TLNClassEnum       `xml:"srcLNClass,attr,omitempty" json:"srcLNClass,omitempty"`
	SrcLNInstAttr   *TLNInst            `xml:"srcLNInst,attr,omitempty" json:"srcLNInst,omitempty"`
	SrcCBNameAttr   *TCBName            `xml:"srcCBName,attr,omitempty" json:"srcCBName,omitempty"`
	PServTAttr      *TServiceType       `xml:"pServT,attr,omitempty" json:"pServT,omitempty"`
	PLNAttr         *TLNClassEnum       `xml:"pLN,attr,omitempty" json:"pLN,omitempty"`
	PDOAttr         *TFullDOName        `xml:"pDO,attr,omitempty" json:"pDO,omitempty"`
	PDAAttr         *TFullAttributeName `xml:"pDA,attr,omitempty" json:"pDA,omitempty"`
}

func (t *TExtRef) Validate() error {
	// AttributeGroup
	if err := t.AgDesc.Validate(); err != nil {
		return err
	}

	// Attributes
	if err := t.IedNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.LdInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.PrefixAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.DoNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.DaNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.ServiceTypeAttr.Validate(); err != nil {
		return err
	}
	if err := t.SrcLDInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.SrcPrefixAttr.Validate(); err != nil {
		return err
	}
	if err := t.SrcLNClassAttr.Validate(); err != nil {
		return err
	}
	if err := t.SrcLNInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.SrcCBNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.PServTAttr.Validate(); err != nil {
		return err
	}
	if err := t.PLNAttr.Validate(); err != nil {
		return err
	}
	if err := t.PDOAttr.Validate(); err != nil {
		return err
	}
	if err := t.PDAAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TLog ...
type TLog struct {
	TUnNaming
	NameAttr *TLogName `xml:"name,attr,omitempty" json:"name,omitempty"`
}

func (t *TLog) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// IEDName ...
type IEDName struct {
	NodeID
	*TIEDName   `xml:",chardata" json:",omitempty"`
	ApRefAttr   *TAccessPointName `xml:"apRef,attr,omitempty" json:"apRef,omitempty"`
	LdInstAttr  *TLDInst          `xml:"ldInst,attr,omitempty" json:"ldInst,omitempty"`
	PrefixAttr  *TPrefix          `xml:"prefix,attr,omitempty" json:"prefix,omitempty"`
	LnClassAttr *TLNClassEnum     `xml:"lnClass,attr,omitempty" json:"lnClass,omitempty"`
	LnInstAttr  *TLNInst          `xml:"lnInst,attr,omitempty" json:"lnInst,omitempty"`
}

func (t *IEDName) Validate() error {
	if err := t.TIEDName.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.ApRefAttr.Validate(); err != nil {
		return err
	}
	if err := t.LdInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.PrefixAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnInstAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TControlWithIEDName ...
type TControlWithIEDName struct {
	TControl
	ConfRevAttr *uint32   `xml:"confRev,attr,omitempty" json:"confRev,omitempty"`
	IEDName     []IEDName `xml:"IEDName" json:"IEDName"`
}

func (t *TControlWithIEDName) Validate() error {
	if err := t.TControl.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.IEDName {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TProtocol ...
type TProtocol struct {
	NodeID
	Content            string `xml:",chardata" json:",omitempty"`
	MustUnderstandAttr bool   `xml:"mustUnderstand,attr" json:"mustUnderstand"`
}

func (t *TProtocol) Validate() error {
	// Content type "string" skipped, is go-based// AttributeGroup

	// Attributes
	// check use='required'  type="bool"
	if t.MustUnderstandAttr == false {
		return fmt.Errorf("requred attribute %q in %s", "mustUnderstand", "TProtocol")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TGSEControl ...
type TGSEControl struct {
	TControlWithIEDName
	TypeAttr           *TGSEControlTypeEnum `xml:"type,attr,omitempty" json:"type,omitempty"`
	AppIDAttr          TMessageID           `xml:"appID,attr" json:"appID"`
	FixedOffsAttr      *bool                `xml:"fixedOffs,attr,omitempty" json:"fixedOffs,omitempty"`
	SecurityEnableAttr *string              `xml:"securityEnable,attr,omitempty" json:"securityEnable,omitempty"`
	Protocol           *TProtocol           `xml:"Protocol" json:"Protocol"`
}

func (t *TGSEControl) Validate() error {
	if err := t.TControlWithIEDName.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	if err := t.AppIDAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tMessageID"
	if t.AppIDAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "appID", "TGSEControl")
	}
	// Elements
	if err := CheckValidate(t.Protocol); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// SmvOpts ...
type SmvOpts struct {
	NodeID
	AgSmvOpts // AttributeGroup
}

func (t *SmvOpts) Validate() error {
	// AttributeGroup
	if err := t.AgSmvOpts.Validate(); err != nil {
		return err
	}

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSampledValueControl ...
type TSampledValueControl struct {
	TControlWithIEDName
	SmvIDAttr          TMessageID                     `xml:"smvID,attr" json:"smvID"`
	MulticastAttr      *bool                          `xml:"multicast,attr,omitempty" json:"multicast,omitempty"`
	SmpRateAttr        uint32                         `xml:"smpRate,attr" json:"smpRate"`
	NofASDUAttr        uint32                         `xml:"nofASDU,attr" json:"nofASDU"`
	SmpModAttr         *TSmpMod                       `xml:"smpMod,attr,omitempty" json:"smpMod,omitempty"`
	SecurityEnableAttr *TPredefinedTypeOfSecurityEnum `xml:"securityEnable,attr,omitempty" json:"securityEnable,omitempty"`
	SmvOpts            SmvOpts                        `xml:"SmvOpts" json:"SmvOpts"`
	Protocol           *TProtocol                     `xml:"Protocol" json:"Protocol"`
}

func (t *TSampledValueControl) Validate() error {
	if err := t.TControlWithIEDName.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.SmvIDAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tMessageID"
	if t.SmvIDAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "smvID", "TSampledValueControl")
	}
	// check use='required'  type="uint32"
	if t.SmpRateAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "smpRate", "TSampledValueControl")
	}
	// check use='required'  type="uint32"
	if t.NofASDUAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "nofASDU", "TSampledValueControl")
	}
	if err := t.SmpModAttr.Validate(); err != nil {
		return err
	}
	if err := t.SecurityEnableAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.SmvOpts); err != nil {
		return err
	}
	if err := CheckValidate(t.Protocol); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TSettingControlNumOfSGsUnsignedInt ...
type TSettingControlNumOfSGsUnsignedInt uint32

func (t *TSettingControlNumOfSGsUnsignedInt) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TSettingControlActSGUnsignedInt ...
type TSettingControlActSGUnsignedInt uint32

func (t *TSettingControlActSGUnsignedInt) Validate() error {

	return nil
}

// "ComplexType"
// TSettingControl ...
type TSettingControl struct {
	TUnNaming
	NumOfSGsAttr TSettingControlNumOfSGsUnsignedInt `xml:"numOfSGs,attr" json:"numOfSGs"`
	ActSGAttr    *TSettingControlActSGUnsignedInt   `xml:"actSG,attr,omitempty" json:"actSG,omitempty"`
	ResvTmsAttr  *uint16                            `xml:"resvTms,attr,omitempty" json:"resvTms,omitempty"`
}

func (t *TSettingControl) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NumOfSGsAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type=""
	if t.NumOfSGsAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "numOfSGs", "TSettingControl")
	}
	if err := t.ActSGAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDOI ...
type TDOI struct {
	TUnNaming
	NameAttr          TDataName `xml:"name,attr" json:"name"`
	IxAttr            *uint32   `xml:"ix,attr,omitempty" json:"ix,omitempty"`
	AccessControlAttr *string   `xml:"accessControl,attr,omitempty" json:"accessControl,omitempty"`
	SDI               []TSDI    `xml:"SDI" json:"SDI"`
	DAI               []TDAI    `xml:"DAI" json:"DAI"`
}

func (t *TDOI) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tDataName"
	if t.NameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "name", "TDOI")
	}
	// Elements
	for _, el := range t.SDI {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.DAI {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSDI ...
type TSDI struct {
	TUnNaming
	NameAttr  TAttributeNameEnum `xml:"name,attr" json:"name"`
	IxAttr    *uint32            `xml:"ix,attr,omitempty" json:"ix,omitempty"`
	SAddrAttr *string            `xml:"sAddr,attr,omitempty" json:"sAddr,omitempty"`
	SDI       []TSDI             `xml:"SDI" json:"SDI"`
	DAI       []TDAI             `xml:"DAI" json:"DAI"`
}

func (t *TSDI) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tAttributeNameEnum"
	if t.NameAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "name", "TSDI")
	}
	// Elements
	for _, el := range t.SDI {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.DAI {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TDAI ...
type TDAI struct {
	TUnNaming
	NameAttr      TAttributeNameEnum `xml:"name,attr" json:"name"`
	SAddrAttr     *string            `xml:"sAddr,attr,omitempty" json:"sAddr,omitempty"`
	ValKindAttr   *TValKindEnum      `xml:"valKind,attr,omitempty" json:"valKind,omitempty"`
	IxAttr        *uint32            `xml:"ix,attr,omitempty" json:"ix,omitempty"`
	ValImportAttr *bool              `xml:"valImport,attr,omitempty" json:"valImport,omitempty"`
	Val           []TVal             `xml:"Val" json:"Val"`
}

func (t *TDAI) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tAttributeNameEnum"
	if t.NameAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "name", "TDAI")
	}
	if err := t.ValKindAttr.Validate(); err != nil {
		return err
	}
	// Elements
	for _, el := range t.Val {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TServiceYesNo ...
type TServiceYesNo struct {
	NodeID
}

func (t *TServiceYesNo) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TServiceWithOptionalMax ...
type TServiceWithOptionalMax struct {
	NodeID
	MaxAttr *uint32 `xml:"max,attr,omitempty" json:"max,omitempty"`
}

func (t *TServiceWithOptionalMax) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TServiceWithMax ...
type TServiceWithMax struct {
	NodeID
	MaxAttr uint32 `xml:"max,attr" json:"max"`
}

func (t *TServiceWithMax) Validate() error {
	// AttributeGroup

	// Attributes
	// check use='required'  type="uint32"
	if t.MaxAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "max", "TServiceWithMax")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TServiceWithMaxNonZeroMaxUnsignedInt ...
type TServiceWithMaxNonZeroMaxUnsignedInt uint32

func (t *TServiceWithMaxNonZeroMaxUnsignedInt) Validate() error {

	return nil
}

// "ComplexType"
// TServiceWithMaxNonZero ...
type TServiceWithMaxNonZero struct {
	NodeID
	MaxAttr TServiceWithMaxNonZeroMaxUnsignedInt `xml:"max,attr" json:"max"`
}

func (t *TServiceWithMaxNonZero) Validate() error {
	// AttributeGroup

	// Attributes
	if err := t.MaxAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type=""
	if t.MaxAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "max", "TServiceWithMaxNonZero")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:Name"
// TServiceConfReportControlBufModeName ...
type TServiceConfReportControlBufModeName string

func (t *TServiceConfReportControlBufModeName) Validate() error {
	// check all enums
	switch *t {
	case TServiceConfReportControlBufModeName_unbuffered:
	case TServiceConfReportControlBufModeName_buffered:
	case TServiceConfReportControlBufModeName_both:
	default:
		return fmt.Errorf("invalid enum value %v for type %s", *t, "TServiceConfReportControlBufModeName")
	}

	return nil
}

const (
	TServiceConfReportControlBufModeName_unbuffered TServiceConfReportControlBufModeName = "unbuffered"
	TServiceConfReportControlBufModeName_buffered   TServiceConfReportControlBufModeName = "buffered"
	TServiceConfReportControlBufModeName_both       TServiceConfReportControlBufModeName = "both"
)

// "ComplexType"
// TServiceConfReportControl ...
type TServiceConfReportControl struct {
	TServiceWithMax
	BufModeAttr *TServiceConfReportControlBufModeName `xml:"bufMode,attr,omitempty" json:"bufMode,omitempty"`
	BufConfAttr *bool                                 `xml:"bufConf,attr,omitempty" json:"bufConf,omitempty"`
	MaxBufAttr  *uint32                               `xml:"maxBuf,attr,omitempty" json:"maxBuf,omitempty"`
}

func (t *TServiceConfReportControl) Validate() error {
	if err := t.TServiceWithMax.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.BufModeAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TServiceWithMaxAndMaxAttributesMaxAttributesUnsignedInt ...
type TServiceWithMaxAndMaxAttributesMaxAttributesUnsignedInt uint32

func (t *TServiceWithMaxAndMaxAttributesMaxAttributesUnsignedInt) Validate() error {

	return nil
}

// "ComplexType"
// TServiceWithMaxAndMaxAttributes ...
type TServiceWithMaxAndMaxAttributes struct {
	TServiceWithMax
	MaxAttributesAttr *TServiceWithMaxAndMaxAttributesMaxAttributesUnsignedInt `xml:"maxAttributes,attr,omitempty" json:"maxAttributes,omitempty"`
}

func (t *TServiceWithMaxAndMaxAttributes) Validate() error {
	if err := t.TServiceWithMax.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.MaxAttributesAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TServiceWithMaxAndModify ...
type TServiceWithMaxAndModify struct {
	TServiceWithMax
	ModifyAttr *bool `xml:"modify,attr,omitempty" json:"modify,omitempty"`
}

func (t *TServiceWithMaxAndModify) Validate() error {
	if err := t.TServiceWithMax.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TServiceForConfDataSet ...
type TServiceForConfDataSet struct {
	TServiceWithMaxAndMaxAttributes
	ModifyAttr *bool `xml:"modify,attr,omitempty" json:"modify,omitempty"`
}

func (t *TServiceForConfDataSet) Validate() error {
	if err := t.TServiceWithMaxAndMaxAttributes.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TClientServicesMaxAttributesUnsignedInt ...
type TClientServicesMaxAttributesUnsignedInt uint32

func (t *TClientServicesMaxAttributesUnsignedInt) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TClientServicesMaxReportsUnsignedInt ...
type TClientServicesMaxReportsUnsignedInt uint32

func (t *TClientServicesMaxReportsUnsignedInt) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TClientServicesMaxGOOSEUnsignedInt ...
type TClientServicesMaxGOOSEUnsignedInt uint32

func (t *TClientServicesMaxGOOSEUnsignedInt) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:unsignedInt"
// TClientServicesMaxSMVUnsignedInt ...
type TClientServicesMaxSMVUnsignedInt uint32

func (t *TClientServicesMaxSMVUnsignedInt) Validate() error {

	return nil
}

// "ComplexType"
// TClientServices ...
type TClientServices struct {
	NodeID
	GooseAttr          *bool                                    `xml:"goose,attr,omitempty" json:"goose,omitempty"`
	GsseAttr           *bool                                    `xml:"gsse,attr,omitempty" json:"gsse,omitempty"`
	BufReportAttr      *bool                                    `xml:"bufReport,attr,omitempty" json:"bufReport,omitempty"`
	UnbufReportAttr    *bool                                    `xml:"unbufReport,attr,omitempty" json:"unbufReport,omitempty"`
	ReadLogAttr        *bool                                    `xml:"readLog,attr,omitempty" json:"readLog,omitempty"`
	SvAttr             *bool                                    `xml:"sv,attr,omitempty" json:"sv,omitempty"`
	SupportsLdNameAttr *bool                                    `xml:"supportsLdName,attr,omitempty" json:"supportsLdName,omitempty"`
	MaxAttributesAttr  *TClientServicesMaxAttributesUnsignedInt `xml:"maxAttributes,attr,omitempty" json:"maxAttributes,omitempty"`
	MaxReportsAttr     *TClientServicesMaxReportsUnsignedInt    `xml:"maxReports,attr,omitempty" json:"maxReports,omitempty"`
	MaxGOOSEAttr       *TClientServicesMaxGOOSEUnsignedInt      `xml:"maxGOOSE,attr,omitempty" json:"maxGOOSE,omitempty"`
	MaxSMVAttr         *TClientServicesMaxSMVUnsignedInt        `xml:"maxSMV,attr,omitempty" json:"maxSMV,omitempty"`
	RGOOSEAttr         *bool                                    `xml:"rGOOSE,attr,omitempty" json:"rGOOSE,omitempty"`
	RSVAttr            *bool                                    `xml:"rSV,attr,omitempty" json:"rSV,omitempty"`
	NoIctBindingAttr   *bool                                    `xml:"noIctBinding,attr,omitempty" json:"noIctBinding,omitempty"`
	TimeSyncProt       *TTimeSyncProt                           `xml:"TimeSyncProt" json:"TimeSyncProt"`
	McSecurity         *TMcSecurity                             `xml:"McSecurity" json:"McSecurity"`
}

func (t *TClientServices) Validate() error {
	// AttributeGroup

	// Attributes
	if err := t.MaxAttributesAttr.Validate(); err != nil {
		return err
	}
	if err := t.MaxReportsAttr.Validate(); err != nil {
		return err
	}
	if err := t.MaxGOOSEAttr.Validate(); err != nil {
		return err
	}
	if err := t.MaxSMVAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.TimeSyncProt); err != nil {
		return err
	}
	if err := CheckValidate(t.McSecurity); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TServiceSettings ...
type TServiceSettings struct {
	NodeID
	CbNameAttr *TServiceSettingsNoDynEnum `xml:"cbName,attr,omitempty" json:"cbName,omitempty"`
	DatSetAttr *TServiceSettingsEnum      `xml:"datSet,attr,omitempty" json:"datSet,omitempty"`
}

func (t *TServiceSettings) Validate() error {
	// AttributeGroup

	// Attributes
	if err := t.CbNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.DatSetAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TReportSettings ...
type TReportSettings struct {
	TServiceSettings
	RptIDAttr     *TServiceSettingsEnum `xml:"rptID,attr,omitempty" json:"rptID,omitempty"`
	OptFieldsAttr *TServiceSettingsEnum `xml:"optFields,attr,omitempty" json:"optFields,omitempty"`
	BufTimeAttr   *TServiceSettingsEnum `xml:"bufTime,attr,omitempty" json:"bufTime,omitempty"`
	TrgOpsAttr    *TServiceSettingsEnum `xml:"trgOps,attr,omitempty" json:"trgOps,omitempty"`
	IntgPdAttr    *TServiceSettingsEnum `xml:"intgPd,attr,omitempty" json:"intgPd,omitempty"`
	ResvTmsAttr   *bool                 `xml:"resvTms,attr,omitempty" json:"resvTms,omitempty"`
	OwnerAttr     *bool                 `xml:"owner,attr,omitempty" json:"owner,omitempty"`
}

func (t *TReportSettings) Validate() error {
	if err := t.TServiceSettings.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.RptIDAttr.Validate(); err != nil {
		return err
	}
	if err := t.OptFieldsAttr.Validate(); err != nil {
		return err
	}
	if err := t.BufTimeAttr.Validate(); err != nil {
		return err
	}
	if err := t.TrgOpsAttr.Validate(); err != nil {
		return err
	}
	if err := t.IntgPdAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TLogSettings ...
type TLogSettings struct {
	TServiceSettings
	LogEnaAttr *TServiceSettingsEnum `xml:"logEna,attr,omitempty" json:"logEna,omitempty"`
	TrgOpsAttr *TServiceSettingsEnum `xml:"trgOps,attr,omitempty" json:"trgOps,omitempty"`
	IntgPdAttr *TServiceSettingsEnum `xml:"intgPd,attr,omitempty" json:"intgPd,omitempty"`
}

func (t *TLogSettings) Validate() error {
	if err := t.TServiceSettings.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.LogEnaAttr.Validate(); err != nil {
		return err
	}
	if err := t.TrgOpsAttr.Validate(); err != nil {
		return err
	}
	if err := t.IntgPdAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TGSESettings ...
type TGSESettings struct {
	TServiceSettings
	AppIDAttr          *TServiceSettingsEnum `xml:"appID,attr,omitempty" json:"appID,omitempty"`
	DataLabelAttr      *TServiceSettingsEnum `xml:"dataLabel,attr,omitempty" json:"dataLabel,omitempty"`
	KdaParticipantAttr *bool                 `xml:"kdaParticipant,attr,omitempty" json:"kdaParticipant,omitempty"`
	McSecurity         *TMcSecurity          `xml:"McSecurity" json:"McSecurity"`
}

func (t *TGSESettings) Validate() error {
	if err := t.TServiceSettings.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.AppIDAttr.Validate(); err != nil {
		return err
	}
	if err := t.DataLabelAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.McSecurity); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSMVSettings ...
type TSMVSettings struct {
	TServiceSettings
	SvIDAttr           *TServiceSettingsEnum      `xml:"svID,attr,omitempty" json:"svID,omitempty"`
	OptFieldsAttr      *TServiceSettingsEnum      `xml:"optFields,attr,omitempty" json:"optFields,omitempty"`
	SmpRateAttr        *TServiceSettingsEnum      `xml:"smpRate,attr,omitempty" json:"smpRate,omitempty"`
	SamplesPerSecAttr  *bool                      `xml:"samplesPerSec,attr,omitempty" json:"samplesPerSec,omitempty"`
	PdcTimeStampAttr   *bool                      `xml:"pdcTimeStamp,attr,omitempty" json:"pdcTimeStamp,omitempty"`
	SynchSrcIdAttr     *bool                      `xml:"synchSrcId,attr,omitempty" json:"synchSrcId,omitempty"`
	NofASDUAttr        *TServiceSettingsNoDynEnum `xml:"nofASDU,attr,omitempty" json:"nofASDU,omitempty"`
	KdaParticipantAttr *bool                      `xml:"kdaParticipant,attr,omitempty" json:"kdaParticipant,omitempty"`
	SmpRate            []uint32                   `xml:"SmpRate" json:"SmpRate"`
	SamplesPerSec      []uint32                   `xml:"SamplesPerSec" json:"SamplesPerSec"`
	SecPerSamples      []uint32                   `xml:"SecPerSamples" json:"SecPerSamples"`
	McSecurity         *TMcSecurity               `xml:"McSecurity" json:"McSecurity"`
}

func (t *TSMVSettings) Validate() error {
	if err := t.TServiceSettings.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.SvIDAttr.Validate(); err != nil {
		return err
	}
	if err := t.OptFieldsAttr.Validate(); err != nil {
		return err
	}
	if err := t.SmpRateAttr.Validate(); err != nil {
		return err
	}
	if err := t.NofASDUAttr.Validate(); err != nil {
		return err
	}
	// Elements
	for _, el := range t.SmpRate {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.SamplesPerSec {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.SecPerSamples {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	if err := CheckValidate(t.McSecurity); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TConfLNs ...
type TConfLNs struct {
	NodeID
	FixPrefixAttr *bool `xml:"fixPrefix,attr,omitempty" json:"fixPrefix,omitempty"`
	FixLnInstAttr *bool `xml:"fixLnInst,attr,omitempty" json:"fixLnInst,omitempty"`
}

func (t *TConfLNs) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TValueHandling ...
type TValueHandling struct {
	NodeID
	SetToROAttr *bool `xml:"setToRO,attr,omitempty" json:"setToRO,omitempty"`
}

func (t *TValueHandling) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TFileHandling ...
type TFileHandling struct {
	TServiceYesNo
	MmsAttr  *bool `xml:"mms,attr,omitempty" json:"mms,omitempty"`
	FtpAttr  *bool `xml:"ftp,attr,omitempty" json:"ftp,omitempty"`
	FtpsAttr *bool `xml:"ftps,attr,omitempty" json:"ftps,omitempty"`
}

func (t *TFileHandling) Validate() error {
	if err := t.TServiceYesNo.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TGOOSEcapabilities ...
type TGOOSEcapabilities struct {
	TServiceWithMax
	FixedOffsAttr *bool `xml:"fixedOffs,attr,omitempty" json:"fixedOffs,omitempty"`
	GooseAttr     *bool `xml:"goose,attr,omitempty" json:"goose,omitempty"`
	RGOOSEAttr    *bool `xml:"rGOOSE,attr,omitempty" json:"rGOOSE,omitempty"`
}

func (t *TGOOSEcapabilities) Validate() error {
	if err := t.TServiceWithMax.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TRedProt ...
type TRedProt struct {
	NodeID
	HsrAttr  *bool `xml:"hsr,attr,omitempty" json:"hsr,omitempty"`
	PrpAttr  *bool `xml:"prp,attr,omitempty" json:"prp,omitempty"`
	RstpAttr *bool `xml:"rstp,attr,omitempty" json:"rstp,omitempty"`
}

func (t *TRedProt) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TTimeSyncProt ...
type TTimeSyncProt struct {
	TServiceYesNo
	SntpAttr       *bool `xml:"sntp,attr,omitempty" json:"sntp,omitempty"`
	Iec6185093Attr *bool `xml:"iec61850_9_3,attr,omitempty" json:"iec61850_9_3,omitempty"`
	C37238Attr     *bool `xml:"c37_238,attr,omitempty" json:"c37_238,omitempty"`
	OtherAttr      *bool `xml:"other,attr,omitempty" json:"other,omitempty"`
}

func (t *TTimeSyncProt) Validate() error {
	if err := t.TServiceYesNo.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSMVsc ...
type TSMVsc struct {
	TServiceWithMax
	DeliveryAttr     *TSMVDeliveryEnum `xml:"delivery,attr,omitempty" json:"delivery,omitempty"`
	DeliveryConfAttr *bool             `xml:"deliveryConf,attr,omitempty" json:"deliveryConf,omitempty"`
	SvAttr           *bool             `xml:"sv,attr,omitempty" json:"sv,omitempty"`
	RSVAttr          *bool             `xml:"rSV,attr,omitempty" json:"rSV,omitempty"`
}

func (t *TSMVsc) Validate() error {
	if err := t.TServiceWithMax.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.DeliveryAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSupSubscription ...
type TSupSubscription struct {
	NodeID
	MaxGoAttr uint32 `xml:"maxGo,attr" json:"maxGo"`
	MaxSvAttr uint32 `xml:"maxSv,attr" json:"maxSv"`
}

func (t *TSupSubscription) Validate() error {
	// AttributeGroup

	// Attributes
	// check use='required'  type="uint32"
	if t.MaxGoAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "maxGo", "TSupSubscription")
	}
	// check use='required'  type="uint32"
	if t.MaxSvAttr == 0 {
		return fmt.Errorf("requred attribute %q in %s", "maxSv", "TSupSubscription")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TCommProt ...
type TCommProt struct {
	TServiceYesNo
	Ipv6Attr *bool `xml:"ipv6,attr,omitempty" json:"ipv6,omitempty"`
}

func (t *TCommProt) Validate() error {
	if err := t.TServiceYesNo.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TMcSecurity ...
type TMcSecurity struct {
	NodeID
	SignatureAttr  *bool `xml:"signature,attr,omitempty" json:"signature,omitempty"`
	EncryptionAttr *bool `xml:"encryption,attr,omitempty" json:"encryption,omitempty"`
}

func (t *TMcSecurity) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TKDC ...
type TKDC struct {
	NodeID
	IedNameAttr TIEDName         `xml:"iedName,attr" json:"iedName"`
	ApNameAttr  TAccessPointName `xml:"apName,attr" json:"apName"`
}

func (t *TKDC) Validate() error {
	// AttributeGroup

	// Attributes
	if err := t.IedNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tIEDName"
	if t.IedNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "iedName", "TKDC")
	}
	if err := t.ApNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tAccessPointName"
	if t.ApNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "apName", "TKDC")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// SGEdit ...
type SGEdit struct {
	TServiceYesNo
	ResvTmsAttr *bool `xml:"resvTms,attr,omitempty" json:"resvTms,omitempty"`
}

func (t *SGEdit) Validate() error {
	if err := t.TServiceYesNo.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// ConfSG ...
type ConfSG struct {
	TServiceYesNo
	ResvTmsAttr *bool `xml:"resvTms,attr,omitempty" json:"resvTms,omitempty"`
}

func (t *ConfSG) Validate() error {
	if err := t.TServiceYesNo.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSettingGroups ...
type TSettingGroups struct {
	NodeID
	SGEdit *SGEdit `xml:"SGEdit" json:"SGEdit"`
	ConfSG *ConfSG `xml:"ConfSG" json:"ConfSG"`
}

func (t *TSettingGroups) Validate() error {
	// AttributeGroup

	// Attributes
	// Elements
	if err := CheckValidate(t.SGEdit); err != nil {
		return err
	}
	if err := CheckValidate(t.ConfSG); err != nil {
		return err
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "Element"
// IED ...
type IED = TIED

/---------------------------------------------------/
Done. test/complex_xsd/SCL_IED.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_BaseTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tVoltage\" set restriction base=\"tValueWithUnit\""
time="2021-11-12T22:35:56+03:00" level=info msg="For Complex type \"tDurationInSec\" set restriction base=\"tValueWithUnit\""
file test/complex_xsd/SCL_Enums.xsd
file test/complex_xsd/SCL_BaseSimpleTypes.xsd
time="2021-11-12T22:35:56+03:00" level=info msg="OutputDir test/go/output/test/complex_xsd"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLNodeContainer"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tPowerSystemResource"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tEquipmentContainer"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tEquipment"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tAbstractConductingEquipment"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tConductingEquipment"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSubEquipment"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tPowerTransformer"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tTransformerWinding"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tTapChanger"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tGeneralEquipment"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSubstation"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tVoltageLevel"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tBay"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLNode"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tFunction"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tSubFunction"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tAbstractEqFuncSubFunc"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tEqFunction"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tEqSubFunction"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tConnectivityNode"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tTerminal"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tGeneralEquipmentContainer"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tLine"
time="2021-11-12T22:35:56+03:00" level=info msg="Render complex type: tProcess"
/---------------------------------------------------/
package schema

import (
	"fmt"
)

// "AttributeGroup"
// AgVirtual ...
type AgVirtual struct {
	VirtualAttr *bool `xml:"virtual,attr,omitempty" json:"virtual,omitempty"`
}

func (t *AgVirtual) Validate() error {

	return nil
}

// "ComplexType"
// TLNodeContainer ...
type TLNodeContainer struct {
	TNaming
	LNode []TLNode `xml:"LNode" json:"LNode"`
}

func (t *TLNodeContainer) Validate() error {
	if err := t.TNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.LNode {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPowerSystemResource ...
type TPowerSystemResource struct {
	TLNodeContainer
}

func (t *TPowerSystemResource) Validate() error {
	if err := t.TLNodeContainer.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TEquipmentContainer ...
type TEquipmentContainer struct {
	TPowerSystemResource
	PowerTransformer []TPowerTransformer `xml:"PowerTransformer" json:"PowerTransformer"`
	GeneralEquipment []TGeneralEquipment `xml:"GeneralEquipment" json:"GeneralEquipment"`
}

func (t *TEquipmentContainer) Validate() error {
	if err := t.TPowerSystemResource.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.PowerTransformer {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.GeneralEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TEquipment ...
type TEquipment struct {
	TPowerSystemResource
	AgVirtual // AttributeGroup
}

func (t *TEquipment) Validate() error {
	if err := t.TPowerSystemResource.Validate(); err != nil {
		return err
	}
	// AttributeGroup
	if err := t.AgVirtual.Validate(); err != nil {
		return err
	}

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TAbstractConductingEquipment ...
type TAbstractConductingEquipment struct {
	TEquipment
	Terminal     []TTerminal     `xml:"Terminal" json:"Terminal"`
	SubEquipment []TSubEquipment `xml:"SubEquipment" json:"SubEquipment"`
}

func (t *TAbstractConductingEquipment) Validate() error {
	if err := t.TEquipment.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.Terminal {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.SubEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TConductingEquipment ...
type TConductingEquipment struct {
	TAbstractConductingEquipment
	TypeAttr   TCommonConductingEquipmentEnum `xml:"type,attr" json:"type"`
	EqFunction []TEqFunction                  `xml:"EqFunction" json:"EqFunction"`
}

func (t *TConductingEquipment) Validate() error {
	if err := t.TAbstractConductingEquipment.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tCommonConductingEquipmentEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TConductingEquipment")
	}
	// Elements
	for _, el := range t.EqFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSubEquipment ...
type TSubEquipment struct {
	TPowerSystemResource
	AgVirtual                // AttributeGroup
	PhaseAttr  *TPhaseEnum   `xml:"phase,attr,omitempty" json:"phase,omitempty"`
	EqFunction []TEqFunction `xml:"EqFunction" json:"EqFunction"`
}

func (t *TSubEquipment) Validate() error {
	if err := t.TPowerSystemResource.Validate(); err != nil {
		return err
	}
	// AttributeGroup
	if err := t.AgVirtual.Validate(); err != nil {
		return err
	}

	// Attributes
	if err := t.PhaseAttr.Validate(); err != nil {
		return err
	}
	// Elements
	for _, el := range t.EqFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TPowerTransformer ...
type TPowerTransformer struct {
	TEquipment
	TypeAttr           TPowerTransformerEnum `xml:"type,attr" json:"type"`
	TransformerWinding []TTransformerWinding `xml:"TransformerWinding" json:"TransformerWinding"`
	SubEquipment       []TSubEquipment       `xml:"SubEquipment" json:"SubEquipment"`
	EqFunction         []TEqFunction         `xml:"EqFunction" json:"EqFunction"`
}

func (t *TPowerTransformer) Validate() error {
	if err := t.TEquipment.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tPowerTransformerEnum"
	if t.TypeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "type", "TPowerTransformer")
	}
	// Elements
	for _, el := range t.TransformerWinding {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.SubEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.EqFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TTransformerWinding ...
type TTransformerWinding struct {
	TAbstractConductingEquipment
	TypeAttr     TTransformerWindingEnum `xml:"type,attr" json:"type"`
	TapChanger   *TTapChanger            `xml:"TapChanger" json:"TapChanger"`
	NeutralPoint *TTerminal              `xml:"NeutralPoint" json:"NeutralPoint"`
	EqFunction   []TEqFunction           `xml:"EqFunction" json:"EqFunction"`
}

func (t *TTransformerWinding) Validate() error {
	if err := t.TAbstractConductingEquipment.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tTransformerWindingEnum"
	if t.TypeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "type", "TTransformerWinding")
	}
	// Elements
	if err := CheckValidate(t.TapChanger); err != nil {
		return err
	}
	if err := CheckValidate(t.NeutralPoint); err != nil {
		return err
	}
	for _, el := range t.EqFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TTapChanger ...
type TTapChanger struct {
	TPowerSystemResource
	AgVirtual                    // AttributeGroup
	TypeAttr     string          `xml:"type,attr" json:"type"`
	SubEquipment []TSubEquipment `xml:"SubEquipment" json:"SubEquipment"`
	EqFunction   []TEqFunction   `xml:"EqFunction" json:"EqFunction"`
}

func (t *TTapChanger) Validate() error {
	if err := t.TPowerSystemResource.Validate(); err != nil {
		return err
	}
	// AttributeGroup
	if err := t.AgVirtual.Validate(); err != nil {
		return err
	}

	// Attributes
	// check use='required'  type="string"
	if t.TypeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "type", "TTapChanger")
	}
	// Elements
	for _, el := range t.SubEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.EqFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TGeneralEquipment ...
type TGeneralEquipment struct {
	TEquipment
	TypeAttr   TGeneralEquipmentEnum `xml:"type,attr" json:"type"`
	EqFunction []TEqFunction         `xml:"EqFunction" json:"EqFunction"`
}

func (t *TGeneralEquipment) Validate() error {
	if err := t.TEquipment.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tGeneralEquipmentEnum"
	if t.TypeAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "type", "TGeneralEquipment")
	}
	// Elements
	for _, el := range t.EqFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSubstation ...
type TSubstation struct {
	TEquipmentContainer
	VoltageLevel []TVoltageLevel `xml:"VoltageLevel" json:"VoltageLevel"`
	Function     []TFunction     `xml:"Function" json:"Function"`
}

func (t *TSubstation) Validate() error {
	if err := t.TEquipmentContainer.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.VoltageLevel {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Function {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:decimal"
// TVoltageLevelNomFreqDecimal ...
type TVoltageLevelNomFreqDecimal float64

func (t *TVoltageLevelNomFreqDecimal) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:unsignedByte"
// TVoltageLevelNumPhasesUnsignedByte ...
type TVoltageLevelNumPhasesUnsignedByte byte

func (t *TVoltageLevelNumPhasesUnsignedByte) Validate() error {

	return nil
}

// "ComplexType"
// TVoltageLevel ...
type TVoltageLevel struct {
	TEquipmentContainer
	NomFreqAttr   *TVoltageLevelNomFreqDecimal        `xml:"nomFreq,attr,omitempty" json:"nomFreq,omitempty"`
	NumPhasesAttr *TVoltageLevelNumPhasesUnsignedByte `xml:"numPhases,attr,omitempty" json:"numPhases,omitempty"`
	Voltage       *TVoltage                           `xml:"Voltage" json:"Voltage"`
	Bay           []TBay                              `xml:"Bay" json:"Bay"`
	Function      []TFunction                         `xml:"Function" json:"Function"`
}

func (t *TVoltageLevel) Validate() error {
	if err := t.TEquipmentContainer.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NomFreqAttr.Validate(); err != nil {
		return err
	}
	if err := t.NumPhasesAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.Voltage); err != nil {
		return err
	}
	for _, el := range t.Bay {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Function {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TBay ...
type TBay struct {
	TEquipmentContainer
	ConductingEquipment []TConductingEquipment `xml:"ConductingEquipment" json:"ConductingEquipment"`
	ConnectivityNode    []TConnectivityNode    `xml:"ConnectivityNode" json:"ConnectivityNode"`
	Function            []TFunction            `xml:"Function" json:"Function"`
}

func (t *TBay) Validate() error {
	if err := t.TEquipmentContainer.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.ConductingEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.ConnectivityNode {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Function {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TLNode ...
type TLNode struct {
	TUnNaming
	IedNameAttr *TIEDNameOrNone `xml:"iedName,attr,omitempty" json:"iedName,omitempty"`
	LdInstAttr  *TLDInstOrEmpty `xml:"ldInst,attr,omitempty" json:"ldInst,omitempty"`
	PrefixAttr  *TPrefix        `xml:"prefix,attr,omitempty" json:"prefix,omitempty"`
	LnClassAttr TLNClassEnum    `xml:"lnClass,attr" json:"lnClass"`
	LnInstAttr  *TLNInstOrEmpty `xml:"lnInst,attr,omitempty" json:"lnInst,omitempty"`
	LnTypeAttr  *TName          `xml:"lnType,attr,omitempty" json:"lnType,omitempty"`
}

func (t *TLNode) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.IedNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.LdInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.PrefixAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnClassAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tLNClassEnum"
	if t.LnClassAttr.IsEmpty() {
		return fmt.Errorf("requred attribute %q in %s", "lnClass", "TLNode")
	}
	if err := t.LnInstAttr.Validate(); err != nil {
		return err
	}
	if err := t.LnTypeAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TFunction ...
type TFunction struct {
	TPowerSystemResource
	TypeAttr            *string                `xml:"type,attr,omitempty" json:"type,omitempty"`
	SubFunction         []TSubFunction         `xml:"SubFunction" json:"SubFunction"`
	GeneralEquipment    []TGeneralEquipment    `xml:"GeneralEquipment" json:"GeneralEquipment"`
	ConductingEquipment []TConductingEquipment `xml:"ConductingEquipment" json:"ConductingEquipment"`
}

func (t *TFunction) Validate() error {
	if err := t.TPowerSystemResource.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.SubFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.GeneralEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.ConductingEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TSubFunction ...
type TSubFunction struct {
	TPowerSystemResource
	TypeAttr            *string                `xml:"type,attr,omitempty" json:"type,omitempty"`
	GeneralEquipment    []TGeneralEquipment    `xml:"GeneralEquipment" json:"GeneralEquipment"`
	ConductingEquipment []TConductingEquipment `xml:"ConductingEquipment" json:"ConductingEquipment"`
	SubFunction         []TSubFunction         `xml:"SubFunction" json:"SubFunction"`
}

func (t *TSubFunction) Validate() error {
	if err := t.TPowerSystemResource.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.GeneralEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.ConductingEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.SubFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TAbstractEqFuncSubFunc ...
type TAbstractEqFuncSubFunc struct {
	TPowerSystemResource
	TypeAttr         *string             `xml:"type,attr,omitempty" json:"type,omitempty"`
	GeneralEquipment []TGeneralEquipment `xml:"GeneralEquipment" json:"GeneralEquipment"`
	EqSubFunction    []TEqSubFunction    `xml:"EqSubFunction" json:"EqSubFunction"`
}

func (t *TAbstractEqFuncSubFunc) Validate() error {
	if err := t.TPowerSystemResource.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.GeneralEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.EqSubFunction {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TEqFunction ...
type TEqFunction struct {
	TAbstractEqFuncSubFunc
}

func (t *TEqFunction) Validate() error {
	if err := t.TAbstractEqFuncSubFunc.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TEqSubFunction ...
type TEqSubFunction struct {
	TAbstractEqFuncSubFunc
}

func (t *TEqSubFunction) Validate() error {
	if err := t.TAbstractEqFuncSubFunc.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TConnectivityNode ...
type TConnectivityNode struct {
	TLNodeContainer
	PathNameAttr TConnectivityNodeReference `xml:"pathName,attr" json:"pathName"`
}

func (t *TConnectivityNode) Validate() error {
	if err := t.TLNodeContainer.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.PathNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tConnectivityNodeReference"
	if t.PathNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "pathName", "TConnectivityNode")
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TTerminal ...
type TTerminal struct {
	TUnNaming
	NameAttr             *TAnyName                  `xml:"name,attr,omitempty" json:"name,omitempty"`
	ConnectivityNodeAttr TConnectivityNodeReference `xml:"connectivityNode,attr" json:"connectivityNode"`
	ProcessNameAttr      *TProcessName              `xml:"processName,attr,omitempty" json:"processName,omitempty"`
	SubstationNameAttr   *TName                     `xml:"substationName,attr,omitempty" json:"substationName,omitempty"`
	VoltageLevelNameAttr *TName                     `xml:"voltageLevelName,attr,omitempty" json:"voltageLevelName,omitempty"`
	BayNameAttr          *TName                     `xml:"bayName,attr,omitempty" json:"bayName,omitempty"`
	CNodeNameAttr        TName                      `xml:"cNodeName,attr" json:"cNodeName"`
	LineNameAttr         *TName                     `xml:"lineName,attr,omitempty" json:"lineName,omitempty"`
}

func (t *TTerminal) Validate() error {
	if err := t.TUnNaming.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.NameAttr.Validate(); err != nil {
		return err
	}
	if err := t.ConnectivityNodeAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tConnectivityNodeReference"
	if t.ConnectivityNodeAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "connectivityNode", "TTerminal")
	}
	if err := t.ProcessNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.SubstationNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.VoltageLevelNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.BayNameAttr.Validate(); err != nil {
		return err
	}
	if err := t.CNodeNameAttr.Validate(); err != nil {
		return err
	}
	// check use='required'  type="tName"
	if t.CNodeNameAttr == "" {
		return fmt.Errorf("requred attribute %q in %s", "cNodeName", "TTerminal")
	}
	if err := t.LineNameAttr.Validate(); err != nil {
		return err
	}
	// Elements

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TGeneralEquipmentContainer ...
type TGeneralEquipmentContainer struct {
	TPowerSystemResource
	GeneralEquipment []TGeneralEquipment `xml:"GeneralEquipment" json:"GeneralEquipment"`
	Function         []TFunction         `xml:"Function" json:"Function"`
}

func (t *TGeneralEquipmentContainer) Validate() error {
	if err := t.TPowerSystemResource.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	// Elements
	for _, el := range t.GeneralEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Function {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "SimpleType"
// base:"xs:decimal"
// TLineNomFreqDecimal ...
type TLineNomFreqDecimal float64

func (t *TLineNomFreqDecimal) Validate() error {

	return nil
}

// "SimpleType"
// base:"xs:unsignedByte"
// TLineNumPhasesUnsignedByte ...
type TLineNumPhasesUnsignedByte byte

func (t *TLineNumPhasesUnsignedByte) Validate() error {

	return nil
}

// "ComplexType"
// TLine ...
type TLine struct {
	TGeneralEquipmentContainer
	TypeAttr            *TLineType                  `xml:"type,attr,omitempty" json:"type,omitempty"`
	NomFreqAttr         *TLineNomFreqDecimal        `xml:"nomFreq,attr,omitempty" json:"nomFreq,omitempty"`
	NumPhasesAttr       *TLineNumPhasesUnsignedByte `xml:"numPhases,attr,omitempty" json:"numPhases,omitempty"`
	Voltage             *TVoltage                   `xml:"Voltage" json:"Voltage"`
	ConductingEquipment []TConductingEquipment      `xml:"ConductingEquipment" json:"ConductingEquipment"`
	ConnectivityNode    []TConnectivityNode         `xml:"ConnectivityNode" json:"ConnectivityNode"`
}

func (t *TLine) Validate() error {
	if err := t.TGeneralEquipmentContainer.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	if err := t.NomFreqAttr.Validate(); err != nil {
		return err
	}
	if err := t.NumPhasesAttr.Validate(); err != nil {
		return err
	}
	// Elements
	if err := CheckValidate(t.Voltage); err != nil {
		return err
	}
	for _, el := range t.ConductingEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.ConnectivityNode {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "ComplexType"
// TProcess ...
type TProcess struct {
	TGeneralEquipmentContainer
	TypeAttr            *TProcessType          `xml:"type,attr,omitempty" json:"type,omitempty"`
	ConductingEquipment []TConductingEquipment `xml:"ConductingEquipment" json:"ConductingEquipment"`
	Substation          []TSubstation          `xml:"Substation" json:"Substation"`
	Line                []TLine                `xml:"Line" json:"Line"`
	Process             []TProcess             `xml:"Process" json:"Process"`
}

func (t *TProcess) Validate() error {
	if err := t.TGeneralEquipmentContainer.Validate(); err != nil {
		return err
	}
	// AttributeGroup

	// Attributes
	if err := t.TypeAttr.Validate(); err != nil {
		return err
	}
	// Elements
	for _, el := range t.ConductingEquipment {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Substation {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Line {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}
	for _, el := range t.Process {
		if err := CheckValidate(el); err != nil {
			return err
		}
	}

	//todo: check "minOccurs" and "maxOccurs"
	return nil
}

// "Element"
// Substation ...
type Substation = TSubstation

// "Element"
// Process ...
type Process = TProcess

// "Element"
// Line ...
type Line = TLine

/---------------------------------------------------/
Done. test/complex_xsd/SCL_Substation.xsd
PASS
ok  	github.com/zoh/xgen-plus	1.489s
