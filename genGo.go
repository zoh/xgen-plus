// Copyright 2020 - 2021 The xgen Authors. All rights reserved. Use of this
// source code is governed by a BSD-style license that can be found in the
// LICENSE file.
//
// Package xgen written in pure Go providing a set of functions that allow you
// to parse XSD (XML schema files). This library needs Go version 1.10 or
// later.

package xgen

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"go/format"
	"os"
	"path"
	"reflect"
	"strings"
)

// CodeGenerator holds code generator overrides and runtime data that are used
// when generate code from proto tree.
type CodeGenerator struct {
	Lang              string
	OutputDir         string
	File              string
	Field             string
	Package           string
	ImportTime        bool // For Go language
	ImportEncodingXML bool // For Go language
	ProtoTree         []interface{}
	StructAST         map[string]string

	log *logrus.Logger

	JsonTag bool

	// todo: validator interface for create validate functions
	Validator interface{}

	// если задан то генерируем файл с базовыми типами
	BaseTypeFile bool
}

var goBuildinType = map[string]bool{
	"xml.Name":      true,
	"byte":          true,
	"[]byte":        true,
	"bool":          true,
	"[]bool":        true,
	"complex64":     true,
	"complex128":    true,
	"float32":       true,
	"float64":       true,
	"int":           true,
	"int8":          true,
	"int16":         true,
	"int32":         true,
	"int64":         true,
	"interface":     true,
	"[]interface{}": true,
	"string":        true,
	"[]string":      true,
	"time.Time":     true,
	"uint":          true,
	"uint8":         true,
	"uint16":        true,
	"uint32":        true,
	"uint64":        true,
}

// GenGo generate Go programming language source code for XML schema
// definition files.
func (gen *CodeGenerator) GenGo() error {
	if gen.BaseTypeFile {
		baseFile := path.Join(gen.OutputDir, "BaseType.go")
		gen.GoBaseFile(baseFile)
	}

	for _, ele := range gen.ProtoTree {
		if ele == nil {
			continue
		}
		tt := reflect.TypeOf(ele).String()[6:]
		funcName := fmt.Sprintf("Go%s", tt)
		gen.Field += fmt.Sprintf("// %q", tt)
		err := callFuncByName(gen, funcName, []reflect.Value{reflect.ValueOf(ele)})
		if err != nil {
			logrus.Fatal(err)
		}
	}
	f, err := os.Create(gen.File + ".go")
	if err != nil {
		return err
	}
	defer f.Close()
	var importPackage, packages string
	if gen.ImportTime {
		packages += "\t\"time\"\n"
	}
	if gen.ImportEncodingXML {
		packages += "\t\"encoding/xml\"\n"
	}
	if packages != "" {
		importPackage = fmt.Sprintf("import (\n%s) \n\n", packages)
	}
	packageName := gen.Package
	if packageName == "" {
		packageName = "schema"
	}
	source, err := format.Source([]byte(fmt.Sprintf("%s\n\npackage %s\n%s%s", copyright, packageName, importPackage, gen.Field)))
	if err != nil {
		_, _ = f.WriteString(fmt.Sprintf("package %s\n%s%s", packageName, importPackage, gen.Field))
		return err
	}
	f.Write(source)

	fmt.Println("/---------------------------------------------------/")
	fmt.Println(string(source))
	fmt.Println("/---------------------------------------------------/")

	return err
}

func genGoFieldName(name string) (fieldName string) {
	for _, str := range strings.Split(name, ":") {
		fieldName += MakeFirstUpperCase(str)
	}
	var tmp string
	for _, str := range strings.Split(fieldName, ".") {
		tmp += MakeFirstUpperCase(str)
	}
	fieldName = tmp
	fieldName = strings.Replace(strings.Replace(fieldName, "-", "", -1), "_", "", -1)
	return
}

func genGoFieldType(name string) string {
	if _, ok := goBuildinType[name]; ok {
		return name
	}
	var fieldType string
	for _, str := range strings.Split(name, ".") {
		fieldType += MakeFirstUpperCase(str)
	}
	fieldType = strings.Replace(MakeFirstUpperCase(strings.Replace(fieldType, "-", "", -1)), "_", "", -1)
	if fieldType != "" {
		return fieldType
	}
	return "interface{}"
}

var copyright = `// Code generated by xgen-plus. DO NOT EDIT.`

// GoSimpleType generates code for simple type XML schema in Go language
// syntax.
func (gen *CodeGenerator) GoSimpleType(v *SimpleType) {
	if v.List {
		if _, ok := gen.StructAST[v.Name]; !ok {
			fieldType := genGoFieldType(getBasefromSimpleType(trimNSPrefix(v.Base), gen.ProtoTree))
			if fieldType == "time.Time" {
				gen.ImportTime = true
			}
			content := fmt.Sprintf(" []%s\n", genGoFieldType(fieldType))
			gen.StructAST[v.Name] = content
			fieldName := genGoFieldName(v.Name)
			gen.Field += fmt.Sprintf("%stype %s%s", genFieldComment(fieldName, v.Doc, "//"), fieldName, gen.StructAST[v.Name])
			return
		}
	}
	if v.Union && len(v.MemberTypes) > 0 {
		if _, ok := gen.StructAST[v.Name]; !ok {
			content := " struct { /* UNION */  \n"
			fieldName := genGoFieldName(v.Name)
			if fieldName != v.Name {
				gen.ImportEncodingXML = true
				//content += fmt.Sprintf("\tXMLName\txml.Name\t`xml:\"%s\"`\n", v.Name)
			}
			for memberName, memberType := range v.MemberTypes {
				if memberType == "" { // fix order issue
					memberType = getBasefromSimpleType(memberName, gen.ProtoTree)
				}
				content += fmt.Sprintf("\t%s\t%s\n", genGoFieldName(memberName), "*"+genGoFieldType(memberType))
			}
			content += "}\n"
			gen.StructAST[v.Name] = content
			gen.Field += fmt.Sprintf("%stype %s%s", genFieldComment(fieldName, v.Doc, "//"), fieldName, gen.StructAST[v.Name])
		}
		return
	}
	if _, ok := gen.StructAST[v.Name]; !ok {
		content := fmt.Sprintf(" %s\n", genGoFieldType(getBasefromSimpleType(trimNSPrefix(v.Base), gen.ProtoTree)))
		gen.StructAST[v.Name] = content
		fieldName := genGoFieldName(trimNSPrefix(v.Name))

		//gen.Field += fmt.Sprintf("// Bse %s\n", v.OrigBase)
		gen.Field += fmt.Sprintf("%stype %s%s",
			genFieldComment(fieldName, v.Doc, "// base:\""+v.OrigBase+"\"\n//"),
			fieldName, gen.StructAST[v.Name])
	}

	if len(v.Restriction.Enum) > 0 {
		var sb strings.Builder
		fieldName := genGoFieldName(trimNSPrefix(v.Name))

		sb.WriteString("const (\n")
		for _, e := range v.Restriction.Enum {
			_, _ = fmt.Fprintf(&sb, "\t%s %s = %q\n", fieldName+"_"+genGoFieldName(e), fieldName, e)
		}
		sb.WriteString(")\n\n")

		gen.Field += sb.String()
	}

	return
}

// GoComplexType generates code for complex type XML schema in Go language
// syntax.
func (gen *CodeGenerator) GoComplexType(v *ComplexType) {
	if _, ok := gen.StructAST[v.Name]; !ok {
		gen.log.Infof("Render complex type: %s", v.Name)

		content := " struct {\n"

		if v.EmbeddedStructName != "" {
			tt := getBasefromSimpleType(trimNSPrefix(v.EmbeddedStructName), gen.ProtoTree)

			_, ok := getSimpleType(v.EmbeddedStructName, gen.ProtoTree)

			if isSimpleType(tt, gen.Lang) || ok {
				// добавляем  NodeID
				content += "NodeID\n"
				//  и пишем как Content ....
				content += fmt.Sprintf("\tContent\t%s\t`xml:\",chardata\" json:\",omitempty\"` \n",
					"*"+genGoFieldName(trimNSPrefix(v.EmbeddedStructName)))
			} else {
				content += "\t" + genGoFieldName(trimNSPrefix(v.EmbeddedStructName)) + "\n"
			}
		} else {
			if v.Base != "" {
				content += genGoFieldName(trimNSPrefix(v.Base)) + "\n"
			} else {
				// добавляем только NodeID
				content += "\tNodeID\n"
			}
		}

		if v.AnyAttributes {
			content += "\tAdditionalFields\tAdditionalFieldsType `xml:\",any,attr\"`\n"
		}
		if v.AnyElements {
			content += "\tCustomElements\t[]AnyHolder\t`xml:\",any\"`\n"
		}

		fieldName := genGoFieldName(v.Name)
		//if fieldName != v.Name {
		//	gen.ImportEncodingXML = true
		//	content += fmt.Sprintf("\tXMLName\txml.Name\t`xml:\"%s\"`\n", v.Name)
		//}

		for _, attrGroup := range v.AttributeGroup {
			fieldType := getBasefromSimpleType(trimNSPrefix(attrGroup.Ref), gen.ProtoTree)
			if fieldType == "time.Time" {
				gen.ImportTime = true
			}
			content += fmt.Sprintf("\t%s\t// AttributeGroup\n", genGoFieldType(fieldType))
		}

		for _, attribute := range v.Attributes {
			vv := attribute.Type // getBasefromSimpleType(trimNSPrefix(attribute.Type), gen.ProtoTree)

			var fieldType string
			if vv == "" && attribute.SimpleTypeInside != nil {
				vv := getBasefromSimpleType(trimNSPrefix(attribute.SimpleTypeInside.Name), gen.ProtoTree)
				fieldType = genGoFieldType(vv)
			} else {
				fieldType = genGoFieldType(vv)
				if fieldType == "time.Time" {
					gen.ImportTime = true
				}
			}

			var optional string
			if attribute.Optional {
				optional = `,omitempty`
				// set how pointer type
				fieldType = "*" + fieldType
			}

			var jsonTag string
			if gen.JsonTag {
				jsonTag = fmt.Sprintf(` json:"%s%s"`, attribute.Name, optional)
			}

			content += fmt.Sprintf("\t%sAttr\t%s\t`xml:\"%s,attr%s\"%s`\n",
				genGoFieldName(attribute.Name), fieldType, attribute.Name, optional, jsonTag)
		}
		for _, group := range v.Groups {
			var plural string
			if group.Plural {
				plural = "[]"
			}
			content += fmt.Sprintf("\t%s\t%s%s\n", genGoFieldName(group.Name), plural, genGoFieldType(getBasefromSimpleType(trimNSPrefix(group.Ref), gen.ProtoTree)))
		}

		for _, element := range v.Elements {
			var plural string
			if element.Plural {
				plural = "[]"
			}
			fieldType := genGoFieldType(getBasefromSimpleType(trimNSPrefix(element.Type), gen.ProtoTree))
			if fieldType == "time.Time" {
				gen.ImportTime = true
			}

			var jsonTag string
			if gen.JsonTag {
				jsonTag = fmt.Sprintf(` json:"%s"`, element.Name)
			}

			content += fmt.Sprintf("\t%s\t%s%s\t`xml:\"%s\"%s`\n",
				genGoFieldName(element.Name), plural, fieldType, element.Name, jsonTag)
		}
		content += "}\n"
		gen.StructAST[v.Name] = content
		gen.Field += fmt.Sprintf("%stype %s%s", genFieldComment(fieldName, v.Doc, "//"), fieldName, gen.StructAST[v.Name])
	}
	return
}

// GoGroup generates code for group XML schema in Go language syntax.
func (gen *CodeGenerator) GoGroup(v *Group) {
	if _, ok := gen.StructAST[v.Name]; !ok {
		content := " struct {\n"
		fieldName := genGoFieldName(v.Name)
		if fieldName != v.Name {
			gen.ImportEncodingXML = true
			//content += fmt.Sprintf("\tXMLName\txml.Name\t`xml:\"%s\"`\n", v.Name)
		}
		for _, element := range v.Elements {
			var plural string
			if element.Plural {
				plural = "[]"
			}
			content += fmt.Sprintf("\t%s\t%s%s\n", genGoFieldName(element.Name), plural, genGoFieldType(getBasefromSimpleType(trimNSPrefix(element.Type), gen.ProtoTree)))
		}

		for _, group := range v.Groups {
			var plural string
			if group.Plural {
				plural = "[]"
			}
			content += fmt.Sprintf("\t%s\t%s%s\n", genGoFieldName(group.Name), plural, genGoFieldType(getBasefromSimpleType(trimNSPrefix(group.Ref), gen.ProtoTree)))
		}

		content += "}\n"
		gen.StructAST[v.Name] = content
		gen.Field += fmt.Sprintf("%stype %s%s", genFieldComment(fieldName, v.Doc, "//"), fieldName, gen.StructAST[v.Name])
	}
	return
}

// GoAttributeGroup generates code for attribute group XML schema in Go language
// syntax.
func (gen *CodeGenerator) GoAttributeGroup(v *AttributeGroup) {
	if _, ok := gen.StructAST[v.Name]; !ok {
		content := " struct {\n"
		fieldName := genGoFieldName(v.Name)
		if fieldName != v.Name {
			gen.ImportEncodingXML = true
			//content += fmt.Sprintf("\tXMLName\txml.Name\t`xml:\"%s\"`\n", v.Name)
		}
		for _, attribute := range v.Attributes {
			var optional string
			if attribute.Optional {
				optional = `,omitempty`
			}

			var jsonTag string
			if gen.JsonTag {
				jsonTag = fmt.Sprintf(` json:"%s%s"`, attribute.Name, optional)
			}

			content += fmt.Sprintf("\t%sAttr\t%s\t`xml:\"%s,attr%s\"%s`\n",
				genGoFieldName(attribute.Name),
				genGoFieldType(getBasefromSimpleType(trimNSPrefix(attribute.Type), gen.ProtoTree)),
				attribute.Name, optional, jsonTag)
		}
		content += "}\n"
		gen.StructAST[v.Name] = content
		gen.Field += fmt.Sprintf("%stype %s%s", genFieldComment(fieldName, v.Doc, "//"), fieldName, gen.StructAST[v.Name])
	}
	return
}

// GoElement generates code for element XML schema in Go language syntax.
func (gen *CodeGenerator) GoElement(v *Element) {
	if _, ok := gen.StructAST[v.Name]; !ok {
		var plural string
		if v.Plural {
			plural = "[]"
		}
		content := fmt.Sprintf("\t%s%s\n", plural, genGoFieldType(getBasefromSimpleType(trimNSPrefix(v.Type), gen.ProtoTree)))
		gen.StructAST[v.Name] = content
		fieldName := genGoFieldName(v.Name)
		gen.Field += fmt.Sprintf("%stype %s%s", genFieldComment(fieldName, v.Doc, "//"), fieldName, gen.StructAST[v.Name])
	}
	return
}

// GoAttribute generates code for attribute XML schema in Go language syntax.
func (gen *CodeGenerator) GoAttribute(v *Attribute) {
	if _, ok := gen.StructAST[v.Name]; !ok {
		var plural string
		if v.Plural {
			plural = "[]"
		}
		content := fmt.Sprintf("\t%s%s\n", plural, genGoFieldType(getBasefromSimpleType(trimNSPrefix(v.Type), gen.ProtoTree)))
		gen.StructAST[v.Name] = content
		fieldName := genGoFieldName(v.Name)
		gen.Field += fmt.Sprintf("%stype %s%s", genFieldComment(fieldName, v.Doc, "//"), fieldName, gen.StructAST[v.Name])
	}
	return
}

func (gen *CodeGenerator) GoBaseFile(file string) {
	f, err := os.Create(file)
	if err != nil {
		logrus.Fatalln(err)
	}
	defer f.Close()

	var packageName = gen.Package
	if packageName == "" {
		packageName = "schema"
	}

	fileRaw, err := os.ReadFile("assets/BaseType.template")
	if err != nil {
		logrus.Fatalln(err)
	}

	s := fmt.Sprintf(string(fileRaw), packageName)
	b := []byte(s)

	b, err = format.Source(b)
	if err != nil {
		logrus.Fatalln(err)
	}
	_, _ = f.Write(b)
}
